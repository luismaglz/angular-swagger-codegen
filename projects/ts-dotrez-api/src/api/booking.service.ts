/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from "rxjs/Observable";
import { map, toPromise } from "rxjs";
import IHttpClient from "../IHttpClient";
import { inject, injectable } from "inversify";
import { IAPIConfiguration } from "../IAPIConfiguration";
import { Headers } from "../Headers";
import HttpResponse from "../HttpResponse";

import { Account } from '../model/account';
import { ActivityProduct } from '../model/activityProduct';
import { AddOn } from '../model/addOn';
import { AddOnAllowedPayments } from '../model/addOnAllowedPayments';
import { AddOnSettings } from '../model/addOnSettings';
import { AutoAssignRequest } from '../model/autoAssignRequest';
import { Booking } from '../model/booking';
import { BookingComment } from '../model/bookingComment';
import { BookingMessageHistory } from '../model/bookingMessageHistory';
import { BookingNotificationHistory } from '../model/bookingNotificationHistory';
import { BookingPointOfSaleEditRequest } from '../model/bookingPointOfSaleEditRequest';
import { BookingQueueRequest } from '../model/bookingQueueRequest';
import { BundleAvailability } from '../model/bundleAvailability';
import { BundleAvailabilityRequest } from '../model/bundleAvailabilityRequest';
import { CarProduct } from '../model/carProduct';
import { CommitPassengerFeeRequest } from '../model/commitPassengerFeeRequest';
import { CommitRequestv2 } from '../model/commitRequestv2';
import { Consumer } from '../model/consumer';
import { DeltaMapperBookingPointOfSaleEditRequest } from '../model/deltaMapperBookingPointOfSaleEditRequest';
import { DeltaMapperConsumer } from '../model/deltaMapperConsumer';
import { DeltaMapperOrderParticipantUpdateRequest } from '../model/deltaMapperOrderParticipantUpdateRequest';
import { DeltaMapperRecordLocatorEditRequest } from '../model/deltaMapperRecordLocatorEditRequest';
import { DivideRequestv2 } from '../model/divideRequestv2';
import { FareOverrideRequest } from '../model/fareOverrideRequest';
import { FareRule } from '../model/fareRule';
import { FeeRequestBase } from '../model/feeRequestBase';
import { FlightMoveHistoryResponse } from '../model/flightMoveHistoryResponse';
import { HistoryResponse } from '../model/historyResponse';
import { HotelProduct } from '../model/hotelProduct';
import { IActionResult } from '../model/iActionResult';
import { IJsonResponse } from '../model/iJsonResponse';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InsuranceProduct } from '../model/insuranceProduct';
import { OrderParticipantUpdateRequest } from '../model/orderParticipantUpdateRequest';
import { OrderPaymentBase } from '../model/orderPaymentBase';
import { PreCancelDetail } from '../model/preCancelDetail';
import { PromotionRequest } from '../model/promotionRequest';
import { RecordLocator } from '../model/recordLocator';
import { RecordLocatorCreateRequest } from '../model/recordLocatorCreateRequest';
import { RecordLocatorEditRequest } from '../model/recordLocatorEditRequest';
import { SeatAssignmentHistoryResponse } from '../model/seatAssignmentHistoryResponse';
import { SeatMapAvailability } from '../model/seatMapAvailability';
import { SegmentChangeHistoryResponse } from '../model/segmentChangeHistoryResponse';
import { SellInsuranceRequest } from '../model/sellInsuranceRequest';
import { ServiceCharge } from '../model/serviceCharge';
import { Transaction } from '../model/transaction';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class BookingService {
    private basePath: string = 'https://localhost';

    constructor(@inject("IApiHttpClient") private httpClient: IHttpClient,
        @inject("IAPIConfiguration") private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * Retrieves the account collection transactions for the booking in state.
     * 
     * @param accountCollectionKey The account collection key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     
     */
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', headers?: Headers): Observable<Array<Transaction>>;
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!accountCollectionKey){
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (!startTime){
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (!sortByNewest){
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        let queryParameters: string[] = [];
        if (startTime !== undefined) {
           queryParameters.push("startTime="+encodeURIComponent(<any>startTime.toISOString()));
        }
        if (endTime !== undefined) {
           queryParameters.push("endTime="+encodeURIComponent(<any>endTime.toISOString()));
        }
        if (sortByNewest !== undefined) {
            queryParameters.push("sortByNewest="+encodeURIComponent(String(sortByNewest)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }
        if (pageIndex !== undefined) {
            queryParameters.push("pageIndex="+encodeURIComponent(String(pageIndex)));
        }


        const response: Observable<HttpResponse<Array<Transaction>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<Transaction>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the account and collections for the booking in state.
     * 
     
     */
    public apiNskV1BookingAccountGet(observe?: 'body', headers?: Headers): Observable<Account>;
    public apiNskV1BookingAccountGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Account>>;
    public apiNskV1BookingAccountGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Account>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/account`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Account>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves all of the transactions for all of the collections for the booking in state.
     * 
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     
     */
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', headers?: Headers): Observable<Array<Transaction>>;
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!startTime){
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingAccountTransactionsGet.');
        }

        if (!sortByNewest){
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingAccountTransactionsGet.');
        }

        let queryParameters: string[] = [];
        if (startTime !== undefined) {
           queryParameters.push("startTime="+encodeURIComponent(<any>startTime.toISOString()));
        }
        if (endTime !== undefined) {
           queryParameters.push("endTime="+encodeURIComponent(<any>endTime.toISOString()));
        }
        if (sortByNewest !== undefined) {
            queryParameters.push("sortByNewest="+encodeURIComponent(String(sortByNewest)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }
        if (pageIndex !== undefined) {
            queryParameters.push("pageIndex="+encodeURIComponent(String(pageIndex)));
        }


        const response: Observable<HttpResponse<Array<Transaction>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/account/transactions?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<Transaction>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     
     */
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<ActivityProduct>>;
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<ActivityProduct>>>;
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (vendorCode !== undefined) {
            queryParameters.push("vendorCode="+encodeURIComponent(String(vendorCode)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<ActivityProduct>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addOns/activities?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<ActivityProduct>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     
     */
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<CarProduct>>;
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<CarProduct>>>;
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (vendorCode !== undefined) {
            queryParameters.push("vendorCode="+encodeURIComponent(String(vendorCode)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<CarProduct>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addOns/cars?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<CarProduct>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     
     */
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<HotelProduct>>;
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<HotelProduct>>>;
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (vendorCode !== undefined) {
            queryParameters.push("vendorCode="+encodeURIComponent(String(vendorCode)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<HotelProduct>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addOns/hotels?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<HotelProduct>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     
     */
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<InsuranceProduct>>;
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<InsuranceProduct>>>;
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (vendorCode !== undefined) {
            queryParameters.push("vendorCode="+encodeURIComponent(String(vendorCode)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<InsuranceProduct>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addOns/insurance?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<InsuranceProduct>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Sells new insurance items.
     * 
     * @param request Quote request.
     
     */
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe?: 'body', headers?: Headers): Observable<IActionResult>;
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IActionResult>>;
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IActionResult>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/addOns/insurance`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IActionResult>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates an order customer for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The customer to update.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyCustomerPatch.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.patch(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/customer`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates an order customer for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The customer to update.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyCustomerPut.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/customer`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes a specific add-on on the booking in state.
     * 
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyDelete.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets a specific add-on from the booking in state.
     * 
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe?: 'body', headers?: Headers): Observable<AddOn>;
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<AddOn>>;
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyGet.');
        }


        const response: Observable<HttpResponse<AddOn>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <AddOn>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates a single participant for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param participantKey The unique participant key.
     * @param request The participant to update.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch.');
        }

        if (!participantKey){
            throw new Error('Required parameter participantKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.patch(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/participants/${encodeURIComponent(String(participantKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates a single participant for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param participantKey The unique participant key.
     * @param request The participant to update.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut.');
        }

        if (!participantKey){
            throw new Error('Required parameter participantKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/participants/${encodeURIComponent(String(participantKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets a specific add-on&#39;s allowed payment methods.
     * If the add on&#39;s payment required flag is set to true, this endpoint  will return the allowed payment options for the add on.  If set to  false, null will be returned.
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe?: 'body', headers?: Headers): Observable<AddOnAllowedPayments>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<AddOnAllowedPayments>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPaymentsGet.');
        }


        const response: Observable<HttpResponse<AddOnAllowedPayments>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/payments`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <AddOnAllowedPayments>(httpResponse.response));
        }
        return response;
    }


    /**
     * Adds a payment to a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The order payment to be added.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPaymentsPost.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/payments`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Pre cancels a specific add-on on the booking in state.
     * 
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe?: 'body', headers?: Headers): Observable<PreCancelDetail>;
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PreCancelDetail>>;
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPreCancelGet.');
        }


        const response: Observable<HttpResponse<PreCancelDetail>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/pre/cancel`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <PreCancelDetail>(httpResponse.response));
        }
        return response;
    }


    /**
     * Syncs the specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeySyncPut.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/sync`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the field validation for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     
     */
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe?: 'body', headers?: Headers): Observable<AddOnSettings>;
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<AddOnSettings>>;
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!addOnKey){
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyValidationGet.');
        }


        const response: Observable<HttpResponse<AddOnSettings>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/validation`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <AddOnSettings>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets all the add-ons on the booking in state.
     * 
     
     */
    public apiNskV1BookingAddonsGet(observe?: 'body', headers?: Headers): Observable<InlineResponse200>;
    public apiNskV1BookingAddonsGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse200>>;
    public apiNskV1BookingAddonsGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<InlineResponse200>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <InlineResponse200>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets all the available add-ons allowed payment methods for all the add-ons on the booking in state.
     * 
     
     */
    public apiNskV1BookingAddonsPaymentsGet(observe?: 'body', headers?: Headers): Observable<InlineResponse2001>;
    public apiNskV1BookingAddonsPaymentsGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse2001>>;
    public apiNskV1BookingAddonsPaymentsGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<InlineResponse2001>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/addons/payments`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <InlineResponse2001>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the baggage allowances for the current booking in state.  Baggage usage details will only be returned if includeUsageDetails  is flagged true AND the allowance behavior is NOT Default.
     * 
     * @param includeUsageDetails If true, the baggage allowance usage details will be populated in the response.  Including these details adds processing overhead, so set this only when absolutely necessary.  Defaults to &#x60;false&#x60;, not include usage details.
     
     */
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe?: 'body', headers?: Headers): Observable<InlineResponse2002>;
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe?: 'response', headers?: Headers): Observable<HttpResponse<InlineResponse2002>>;
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (includeUsageDetails !== undefined) {
            queryParameters.push("includeUsageDetails="+encodeURIComponent(String(includeUsageDetails)));
        }


        const response: Observable<HttpResponse<InlineResponse2002>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/baggageAllowances?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <InlineResponse2002>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the bundle and ssr availability for the booking in-state.
     * Although this endpoint behaves like a GET, POST reduces the limitations resulting from URL length issues.
     * @param request The bundle availability request.
     
     */
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe?: 'body', headers?: Headers): Observable<Array<BundleAvailability>>;
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<BundleAvailability>>>;
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<BundleAvailability>>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/bundle/availability`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<BundleAvailability>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the list of comments on the in-state booking.
     * 
     
     */
    public apiNskV1BookingCommentsGet(observe?: 'body', headers?: Headers): Observable<Array<BookingComment>>;
    public apiNskV1BookingCommentsGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<BookingComment>>>;
    public apiNskV1BookingCommentsGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<BookingComment>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/comments`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<BookingComment>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Replaces an existing fare price with an amount specified.
     * 
     * @param journeyKey The journey key.
     * @param request The fare override request.
     
     */
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!journeyKey){
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingFareOverrideJourneyByJourneyKeyPost.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/fareOverride/journey/${encodeURIComponent(String(journeyKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves a fare rule from the current booking in state based on  the specific fare key.
     * 
     * @param fareKey The unique fare key.
     
     */
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe?: 'body', headers?: Headers): Observable<FareRule>;
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<FareRule>>;
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!fareKey){
            throw new Error('Required parameter fareKey was null or undefined when calling apiNskV1BookingFareRulesFareByFareKeyGet.');
        }


        const response: Observable<HttpResponse<FareRule>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/fareRules/fare/${encodeURIComponent(String(fareKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <FareRule>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the collection of all fare rules from the current booking in state.
     * 
     
     */
    public apiNskV1BookingFareRulesGet(observe?: 'body', headers?: Headers): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<FareRule>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/fareRules`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<FareRule>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the collection of all fare rules from the current booking in state  for the specific journey key.
     * 
     * @param journeyKey The unique journey key.
     
     */
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe?: 'body', headers?: Headers): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!journeyKey){
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingFareRulesJourneyByJourneyKeyGet.');
        }


        const response: Observable<HttpResponse<Array<FareRule>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/fareRules/journey/${encodeURIComponent(String(journeyKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<FareRule>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the collection of all fare rules from the current booking in state for the specific segment key.
     * 
     * @param segmentKey The unique segment key.
     
     */
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe?: 'body', headers?: Headers): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!segmentKey){
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingFareRulesSegmentBySegmentKeyGet.');
        }


        const response: Observable<HttpResponse<Array<FareRule>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/fareRules/segment/${encodeURIComponent(String(segmentKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<FareRule>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes a fee.
     * 
     * @param feeKey The fee key request.
     
     */
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!feeKey){
            throw new Error('Required parameter feeKey was null or undefined when calling apiNskV1BookingFeeByFeeKeyDelete.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/fee/${encodeURIComponent(String(feeKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Overrides a fee amount.
     * 
     * @param feeKey The fee key.
     * @param request The fee request.
     
     */
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!feeKey){
            throw new Error('Required parameter feeKey was null or undefined when calling apiNskV1BookingFeeByFeeKeyPut.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/fee/${encodeURIComponent(String(feeKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the fee price.
     * Only service and penalty fee types support a price that is configured by the booking in state.  Depending on the configuration, the passenger key will be needed.  For other fee types the price amount is manually provided.
     * @param feeCode The fee code.
     * @param passengerKey The passenger key.
     * @param origin The origin station code.
     * @param collectedCurrencyCode The collected currency code.
     
     */
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe?: 'body', headers?: Headers): Observable<Array<ServiceCharge>>;
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<ServiceCharge>>>;
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!feeCode){
            throw new Error('Required parameter feeCode was null or undefined when calling apiNskV1BookingFeeGet.');
        }

        let queryParameters: string[] = [];
        if (passengerKey !== undefined) {
            queryParameters.push("passengerKey="+encodeURIComponent(String(passengerKey)));
        }
        if (origin !== undefined) {
            queryParameters.push("origin="+encodeURIComponent(String(origin)));
        }
        if (collectedCurrencyCode !== undefined) {
            queryParameters.push("collectedCurrencyCode="+encodeURIComponent(String(collectedCurrencyCode)));
        }
        if (feeCode !== undefined) {
            queryParameters.push("feeCode="+encodeURIComponent(String(feeCode)));
        }


        const response: Observable<HttpResponse<Array<ServiceCharge>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/fee?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<ServiceCharge>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Manually adds a new fee.
     * Penalty fees, spoilage fees, and service fees can be created manually. Other types are automatically created by  the system.  Depending on the configuration, the passenger key will be needed.
     * @param request The fee request.
     
     */
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/fee`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Get the current booking in state.
     * 
     
     */
    public apiNskV1BookingGet(observe?: 'body', headers?: Headers): Observable<Booking>;
    public apiNskV1BookingGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Booking>>;
    public apiNskV1BookingGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Booking>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Booking>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current flight move history in state.
     * 
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     
     */
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe?: 'body', headers?: Headers): Observable<FlightMoveHistoryResponse>;
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<FlightMoveHistoryResponse>>;
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (lastPageKey !== undefined) {
            queryParameters.push("lastPageKey="+encodeURIComponent(String(lastPageKey)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }


        const response: Observable<HttpResponse<FlightMoveHistoryResponse>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history/flightMove?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <FlightMoveHistoryResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current booking history in state.
     * 
     * @param event The event that triggered the history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     
     */
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'body', headers?: Headers): Observable<HistoryResponse>;
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<HistoryResponse>>;
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (event !== undefined) {
            queryParameters.push("event="+encodeURIComponent(String(event)));
        }
        if (lastPageKey !== undefined) {
            queryParameters.push("lastPageKey="+encodeURIComponent(String(lastPageKey)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }


        const response: Observable<HttpResponse<HistoryResponse>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <HistoryResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current message history in state.
     * 
     
     */
    public apiNskV1BookingHistoryMessageGet(observe?: 'body', headers?: Headers): Observable<Array<BookingMessageHistory>>;
    public apiNskV1BookingHistoryMessageGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<BookingMessageHistory>>>;
    public apiNskV1BookingHistoryMessageGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<BookingMessageHistory>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history/message`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<BookingMessageHistory>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current notification history in state.
     * 
     
     */
    public apiNskV1BookingHistoryNotificationGet(observe?: 'body', headers?: Headers): Observable<Array<BookingNotificationHistory>>;
    public apiNskV1BookingHistoryNotificationGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<BookingNotificationHistory>>>;
    public apiNskV1BookingHistoryNotificationGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<BookingNotificationHistory>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history/notification`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<BookingNotificationHistory>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current seat assignment history in state.
     * 
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     
     */
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'body', headers?: Headers): Observable<SeatAssignmentHistoryResponse>;
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<SeatAssignmentHistoryResponse>>;
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!event){
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingHistorySeatAssignmentGet.');
        }

        let queryParameters: string[] = [];
        if (event !== undefined) {
            queryParameters.push("event="+encodeURIComponent(String(event)));
        }
        if (lastPageKey !== undefined) {
            queryParameters.push("lastPageKey="+encodeURIComponent(String(lastPageKey)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }


        const response: Observable<HttpResponse<SeatAssignmentHistoryResponse>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history/seatAssignment?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <SeatAssignmentHistoryResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the current segment change history in state.
     * 
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     
     */
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'body', headers?: Headers): Observable<SegmentChangeHistoryResponse>;
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'response', headers?: Headers): Observable<HttpResponse<SegmentChangeHistoryResponse>>;
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!event){
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingHistorySegmentChangeGet.');
        }

        let queryParameters: string[] = [];
        if (event !== undefined) {
            queryParameters.push("event="+encodeURIComponent(String(event)));
        }
        if (lastPageKey !== undefined) {
            queryParameters.push("lastPageKey="+encodeURIComponent(String(lastPageKey)));
        }
        if (pageSize !== undefined) {
            queryParameters.push("pageSize="+encodeURIComponent(String(pageSize)));
        }


        const response: Observable<HttpResponse<SegmentChangeHistoryResponse>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/history/segmentChange?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <SegmentChangeHistoryResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates the booking point of sale.
     * The ISO country code cannot be updated for a committed booking.  This value can only be  updated on an uncommitted booking.
     * @param request Details to update the point of sale.
     
     */
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.patch(`${this.basePath}/api/nsk/v1/booking/pointOfSale`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates the booking point of sale.
     * The ISO country code cannot be updated for a committed booking.  This value can only be  updated on an uncommitted booking.
     * @param request Details to update the point of sale.
     
     */
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/pointOfSale`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes the promotion code on the booking in state.
     * 
     
     */
    public apiNskV1BookingPromotionDelete(observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingPromotionDelete(observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPromotionDelete(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/promotion`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Sets a promotion code to a booking in state.
     * 
     * @param request Promotion request.
     
     */
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe?: 'body', headers?: Headers): Observable<any>;
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<any>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/promotion`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <any>(httpResponse.response));
        }
        return response;
    }


    /**
     * Updates a promotion code to a booking in state.
     * 
     * @param request Promotion request.
     
     */
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/promotion`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Removes the booking in state from a booking queue.
     * 
     * @param request The booking request.
     
     */
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/queue`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Adds the booking from state to a booking queue.
     * 
     * @param request The booking request.
     
     */
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/queue`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes a record locator from the booking.
     * 
     * @param recordLocatorKey The record locator key.
     
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!recordLocatorKey){
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the record locator associated with the record locator key for  the in-state booking.
     * 
     * @param recordLocatorKey 
     
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe?: 'body', headers?: Headers): Observable<RecordLocator>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<RecordLocator>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!recordLocatorKey){
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet.');
        }


        const response: Observable<HttpResponse<RecordLocator>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <RecordLocator>(httpResponse.response));
        }
        return response;
    }


    /**
     * Patches the data of a third party record locator on the booking.
     * 
     * @param recordLocatorKey The record locator key to update.
     * @param request The record locator update request.
     
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!recordLocatorKey){
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.patch(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Replaces the data of a third party record locator on the booking.
     * 
     * @param recordLocatorKey The record locator key to update.
     * @param request The record locator update request.
     
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!recordLocatorKey){
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes all record locators from the booking.
     * 
     
     */
    public apiNskV1BookingRecordLocatorsDelete(observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsDelete(observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsDelete(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/recordLocators`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets all of the record locators on the in-state booking.
     * 
     
     */
    public apiNskV1BookingRecordLocatorsGet(observe?: 'body', headers?: Headers): Observable<Array<RecordLocator>>;
    public apiNskV1BookingRecordLocatorsGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<RecordLocator>>>;
    public apiNskV1BookingRecordLocatorsGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Array<RecordLocator>>> = this.httpClient.get(`${this.basePath}/api/nsk/v1/booking/recordLocators`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<RecordLocator>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Adds a third party record locator to the booking.
     * 
     * @param request The record locator request.
     
     */
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/recordLocators`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Clears the current booking state.
     * 
     
     */
    public apiNskV1BookingResetDelete(observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingResetDelete(observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingResetDelete(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/reset`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Overrides the effective sales channel for the booking in state.
     * For the overriden channel to be implemented, the booking in state must be committed after calling this endpoint.
     * @param channelType The sales channel type to override to.
     
     */
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (channelType !== undefined) {
            queryParameters.push("channelType="+encodeURIComponent(String(channelType)));
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v1/booking/salesChannel?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Auto assigns seats to all passengers that do not have them for a specific journey.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param journeyKey The specific journey key to auto assign.
     * @param request The auto assign seat request.
     
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!primaryPassengerKey){
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost.');
        }

        if (!journeyKey){
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}/journey/${encodeURIComponent(String(journeyKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Auto assigns seats to all selected passengers that do not have them for every journey on the booking.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param request The auto assign seat request.
     
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!primaryPassengerKey){
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Auto assigns seats to all passengers that do not have them for a specific journey&#39;s segment.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param segmentKey The specific segment key to auto assign.
     * @param request The auto assign seat request.
     
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!primaryPassengerKey){
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost.');
        }

        if (!segmentKey){
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}/segment/${encodeURIComponent(String(segmentKey))}`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Cancels the specific segment from the booking in state.
     * Calling this method will alter the existing journeyKey. If you are cancelling the only segment in a journey,  this method will behave the same as calling DELETE on /api/nsk/v1/booking/journeys/{journeyKey}.   If there are segments remaining after the delete, the Location response header will be set with   the location of the modified journey with its new key.
     * @param segmentKey The key of the specific segment to be canceled.
     
     */
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!segmentKey){
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingSegmentsBySegmentKeyDelete.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v1/booking/segments/${encodeURIComponent(String(segmentKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Deletes a comment from the booking.
     * 
     * @param commentKey The booking comment key.
     
     */
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!commentKey){
            throw new Error('Required parameter commentKey was null or undefined when calling apiNskV2BookingCommentsByCommentKeyDelete.');
        }


        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.delete(`${this.basePath}/api/nsk/v2/booking/comments/${encodeURIComponent(String(commentKey))}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Divides the current booking.
     * A valid user must be logged in to divide a booking.
     * @param request Contains the divide request information.
     
     */
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v2/booking/divide`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Retrieves the recommended hold date if hold is available.
     * 
     
     */
    public apiNskV2BookingHoldAvailableGet(observe?: 'body', headers?: Headers): Observable<Date>;
    public apiNskV2BookingHoldAvailableGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Date>>;
    public apiNskV2BookingHoldAvailableGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Date>> = this.httpClient.get(`${this.basePath}/api/nsk/v2/booking/hold/available`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Date>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the list of seat maps for all the journeys for the booking in state.
     * 
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     
     */
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<SeatMapAvailability>>;
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (includePropertyLookup !== undefined) {
            queryParameters.push("includePropertyLookup="+encodeURIComponent(String(includePropertyLookup)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<SeatMapAvailability>>> = this.httpClient.get(`${this.basePath}/api/nsk/v2/booking/seatmaps?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<SeatMapAvailability>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the list of seat maps for a specific journey&#39;s segment.
     * 
     * @param segmentKey The segment key.
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     
     */
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<SeatMapAvailability>>;
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!segmentKey){
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV2BookingSeatmapsSegmentBySegmentKeyGet.');
        }

        let queryParameters: string[] = [];
        if (includePropertyLookup !== undefined) {
            queryParameters.push("includePropertyLookup="+encodeURIComponent(String(includePropertyLookup)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<SeatMapAvailability>>> = this.httpClient.get(`${this.basePath}/api/nsk/v2/booking/seatmaps/segment/${encodeURIComponent(String(segmentKey))}?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<SeatMapAvailability>>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the status of the booking commit and returns the booking.
     * There are certain booking data that are not saved to state, such as payment   attachments. This endpoint will return the booking data so that non persisted   information is returned when and only when the status code is 200. This is the   only time the data will be available.
     
     */
    public apiNskV2BookingStatusGet(observe?: 'body', headers?: Headers): Observable<Booking>;
    public apiNskV2BookingStatusGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<Booking>>;
    public apiNskV2BookingStatusGet(observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<Booking>> = this.httpClient.get(`${this.basePath}/api/nsk/v2/booking/status`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Booking>(httpResponse.response));
        }
        return response;
    }


    /**
     * Commits stateful changes made and processes the booking.
     * 
     * @param request Commit request.
     
     */
    public apiNskV3BookingPost(request?: CommitRequestv2, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV3BookingPost(request?: CommitRequestv2, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV3BookingPost(request?: CommitRequestv2, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.post(`${this.basePath}/api/nsk/v3/booking`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Commits stateful changes made and processes the booking.
     * 
     * @param request Commit request.
     
     */
    public apiNskV3BookingPut(request?: CommitRequestv2, observe?: 'body', headers?: Headers): Observable<IJsonResponse>;
    public apiNskV3BookingPut(request?: CommitRequestv2, observe?: 'response', headers?: Headers): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV3BookingPut(request?: CommitRequestv2, observe: any = 'body', headers: Headers = {}): Observable<any> {

        const response: Observable<HttpResponse<IJsonResponse>> = this.httpClient.put(`${this.basePath}/api/nsk/v3/booking`, request , headers);
        if (observe == 'body') {
               return response.map(httpResponse => <IJsonResponse>(httpResponse.response));
        }
        return response;
    }


    /**
     * Gets the list of seat maps for an entire journey.
     * 
     * @param journeyKey The unique journey key.
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     
     */
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', headers?: Headers): Observable<Array<SeatMapAvailability>>;
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (!journeyKey){
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV3BookingSeatmapsJourneyByJourneyKeyGet.');
        }

        let queryParameters: string[] = [];
        if (includePropertyLookup !== undefined) {
            queryParameters.push("includePropertyLookup="+encodeURIComponent(String(includePropertyLookup)));
        }
        if (cultureCode !== undefined) {
            queryParameters.push("cultureCode="+encodeURIComponent(String(cultureCode)));
        }


        const response: Observable<HttpResponse<Array<SeatMapAvailability>>> = this.httpClient.get(`${this.basePath}/api/nsk/v3/booking/seatmaps/journey/${encodeURIComponent(String(journeyKey))}?${queryParameters.join('&')}`, headers);
        if (observe == 'body') {
               return response.map(httpResponse => <Array<SeatMapAvailability>>(httpResponse.response));
        }
        return response;
    }

}
