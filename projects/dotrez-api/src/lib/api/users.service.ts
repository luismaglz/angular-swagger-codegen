/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BookingSearchResult } from '../model/bookingSearchResult';
import { BookingTripResult } from '../model/bookingTripResult';
import { DeltaMapperPersonAddressEditRequest } from '../model/deltaMapperPersonAddressEditRequest';
import { DeltaMapperPersonAliasRequest } from '../model/deltaMapperPersonAliasRequest';
import { DeltaMapperPersonCommentRequest } from '../model/deltaMapperPersonCommentRequest';
import { DeltaMapperPersonCustomerProgramEditRequest } from '../model/deltaMapperPersonCustomerProgramEditRequest';
import { DeltaMapperPersonEditRequest } from '../model/deltaMapperPersonEditRequest';
import { DeltaMapperPersonEmailEditRequest } from '../model/deltaMapperPersonEmailEditRequest';
import { DeltaMapperPersonInformationEditRequest } from '../model/deltaMapperPersonInformationEditRequest';
import { DeltaMapperPersonPhoneNumberRequest } from '../model/deltaMapperPersonPhoneNumberRequest';
import { DeltaMapperPersonPreferenceEditRequest } from '../model/deltaMapperPersonPreferenceEditRequest';
import { DeltaMapperPersonStoredPaymentUpdateRequest } from '../model/deltaMapperPersonStoredPaymentUpdateRequest';
import { DeltaMapperTravelDocumentEditRequestv2 } from '../model/deltaMapperTravelDocumentEditRequestv2';
import { DeltaMapperTravelNotificationEditRequest } from '../model/deltaMapperTravelNotificationEditRequest';
import { DeltaMapperUserRequest } from '../model/deltaMapperUserRequest';
import { DeltaMapperUserRolePatchRequest } from '../model/deltaMapperUserRolePatchRequest';
import { IJsonResponse } from '../model/iJsonResponse';
import { NotificationEvent } from '../model/notificationEvent';
import { NotificationEventCreateRequest } from '../model/notificationEventCreateRequest';
import { NotificationTimedEvent } from '../model/notificationTimedEvent';
import { NotificationTimedEventCreateRequest } from '../model/notificationTimedEventCreateRequest';
import { NotificationTimedEventEditRequest } from '../model/notificationTimedEventEditRequest';
import { Person } from '../model/person';
import { PersonAddress } from '../model/personAddress';
import { PersonAddressCreateRequest } from '../model/personAddressCreateRequest';
import { PersonAddressEditRequest } from '../model/personAddressEditRequest';
import { PersonAlias } from '../model/personAlias';
import { PersonAliasRequest } from '../model/personAliasRequest';
import { PersonComment } from '../model/personComment';
import { PersonCommentRequest } from '../model/personCommentRequest';
import { PersonCustomerProgram } from '../model/personCustomerProgram';
import { PersonCustomerProgramCreateRequest } from '../model/personCustomerProgramCreateRequest';
import { PersonCustomerProgramEditRequest } from '../model/personCustomerProgramEditRequest';
import { PersonEditRequest } from '../model/personEditRequest';
import { PersonEmail } from '../model/personEmail';
import { PersonEmailCreateRequest } from '../model/personEmailCreateRequest';
import { PersonEmailEditRequest } from '../model/personEmailEditRequest';
import { PersonInformation } from '../model/personInformation';
import { PersonInformationCreateRequest } from '../model/personInformationCreateRequest';
import { PersonInformationEditRequest } from '../model/personInformationEditRequest';
import { PersonPhoneNumber } from '../model/personPhoneNumber';
import { PersonPhoneNumberRequest } from '../model/personPhoneNumberRequest';
import { PersonPreference } from '../model/personPreference';
import { PersonPreferenceCreateRequest } from '../model/personPreferenceCreateRequest';
import { PersonPreferenceEditRequest } from '../model/personPreferenceEditRequest';
import { PersonStoredPayment } from '../model/personStoredPayment';
import { PersonStoredPaymentRequest } from '../model/personStoredPaymentRequest';
import { PersonStoredPaymentUpdateRequest } from '../model/personStoredPaymentUpdateRequest';
import { PersonTravelDocument } from '../model/personTravelDocument';
import { PersonTravelDocumentRequest } from '../model/personTravelDocumentRequest';
import { TravelDocumentEditRequestv2 } from '../model/travelDocumentEditRequestv2';
import { TravelNotification } from '../model/travelNotification';
import { TravelNotificationCreateRequest } from '../model/travelNotificationCreateRequest';
import { TravelNotificationEditRequest } from '../model/travelNotificationEditRequest';
import { User } from '../model/user';
import { UserChangePasswordRequestBase } from '../model/userChangePasswordRequestBase';
import { UserCreateRequest } from '../model/userCreateRequest';
import { UserCreateRequestv2 } from '../model/userCreateRequestv2';
import { UserRecord } from '../model/userRecord';
import { UserRequest } from '../model/userRequest';
import { UserRole } from '../model/userRole';
import { UserRoleCreateRequest } from '../model/userRoleCreateRequest';
import { UserRoleEditRequest } from '../model/userRoleEditRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UsersService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Searches the specific user upcoming and past bookings by passenger.
     * This is similar to the user booking endpoint but returns more focused trip information.  This endpoint will only return data where a bookings passenger customer number matches the current logged in user.  Bookings made by the user but where the passenger customer are not assigned are ignored.
     * @param userKey The user key.
     * @param startDate Booking start search date.
     * @param endDate Booking end search date.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyBookingsByPassengerGet(userKey: string, startDate?: Date, endDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingTripResult>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyBookingsByPassengerGet(userKey: string, startDate?: Date, endDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingTripResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyBookingsByPassengerGet(userKey: string, startDate?: Date, endDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingTripResult>>>;
    public apiNskV1UsersByUserKeyBookingsByPassengerGet(userKey: string, startDate?: Date, endDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyBookingsByPassengerGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('StartDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('EndDate', <any>endDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingTripResult>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/bookingsByPassenger`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Searches the specific user for upcoming and past bookings.
     * 
     * @param userKey The unique user key.
     * @param returnCount The number of results to be returned.
     * @param associatedFirstName An associated passenger/contact first name.
     * @param associatedLastName An associated passenger/contact last name.
     * @param phoneticSearch Flag indicating to search using the phonetic option.
     * @param tripIdentifier Filter by trip identifier.
     * @param origin Filter by origin station code.
     * @param destination Filter by destination station code.
     * @param searchArchive Flag indicating to search archived bookings.
     * @param tripDate Filter by trip date.
     * @param startDate Filter by starting search date.
     * @param endDate Filter by ending search date.
     * @param searchByCustomerNumber Flag indicating to search by the users customer number instead of user identifier.
     * @param lastBookingKey The last booking key (used for paging).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyBookingsGet(userKey: string, returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyBookingsGet(userKey: string, returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyBookingsGet(userKey: string, returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1UsersByUserKeyBookingsGet(userKey: string, returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyBookingsGet.');
        }

        if (returnCount === null || returnCount === undefined) {
            throw new Error('Required parameter returnCount was null or undefined when calling apiNskV1UsersByUserKeyBookingsGet.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (associatedFirstName !== undefined && associatedFirstName !== null) {
            queryParameters = queryParameters.set('AssociatedFirstName', <any>associatedFirstName);
        }
        if (associatedLastName !== undefined && associatedLastName !== null) {
            queryParameters = queryParameters.set('AssociatedLastName', <any>associatedLastName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (tripIdentifier !== undefined && tripIdentifier !== null) {
            queryParameters = queryParameters.set('TripIdentifier', <any>tripIdentifier);
        }
        if (origin !== undefined && origin !== null) {
            queryParameters = queryParameters.set('Origin', <any>origin);
        }
        if (destination !== undefined && destination !== null) {
            queryParameters = queryParameters.set('Destination', <any>destination);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }
        if (tripDate !== undefined && tripDate !== null) {
            queryParameters = queryParameters.set('TripDate', <any>tripDate.toISOString());
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('StartDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('EndDate', <any>endDate.toISOString());
        }
        if (searchByCustomerNumber !== undefined && searchByCustomerNumber !== null) {
            queryParameters = queryParameters.set('SearchByCustomerNumber', <any>searchByCustomerNumber);
        }
        if (returnCount !== undefined && returnCount !== null) {
            queryParameters = queryParameters.set('ReturnCount', <any>returnCount);
        }
        if (lastBookingKey !== undefined && lastBookingKey !== null) {
            queryParameters = queryParameters.set('LastBookingKey', <any>lastBookingKey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/bookings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the user.
     * This is a soft delete by setting the user record status to terminated.
     * @param userKey User key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyDelete(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyDelete(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyDelete(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyDelete(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the a specific user.
     * 
     * @param userKey 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:User,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:User,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public apiNskV1UsersByUserKeyGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<User>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Changes a specifics user&#39;s password.
     * 
     * @param userKey The unique user key.
     * @param request The change password request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPasswordChangePost(userKey: string, request?: UserChangePasswordRequestBase, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPasswordChangePost(userKey: string, request?: UserChangePasswordRequestBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPasswordChangePost(userKey: string, request?: UserChangePasswordRequestBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPasswordChangePost(userKey: string, request?: UserChangePasswordRequestBase, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPasswordChangePost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/password/change`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Invokes the forgot password reset for a specific user.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPasswordResetPost(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPasswordResetPost(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPasswordResetPost(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPasswordResetPost(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPasswordResetPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/password/reset`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the current logged in user.
     * 
     * @param userKey The unique user key.
     * @param request The user patch request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPatch(userKey: string, request?: DeltaMapperUserRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPatch(userKey: string, request?: DeltaMapperUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPatch(userKey: string, request?: DeltaMapperUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPatch(userKey: string, request?: DeltaMapperUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAddressKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete(userKey: string, personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete(userKey: string, personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete(userKey: string, personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete(userKey: string, personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific address from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAddressKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet(userKey: string, personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonAddress,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet(userKey: string, personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonAddress,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet(userKey: string, personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAddress>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet(userKey: string, personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAddress>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAddressKey The unique person address key.
     * @param request The patched address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch(userKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch(userKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch(userKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch(userKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAddressKey The unique person address key.
     * @param request The modified address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut(userKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut(userKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut(userKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut(userKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesByPersonAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all addresses from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonAddress>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonAddress>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAddress>>>;
    public apiNskV1UsersByUserKeyPersonAddressesGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAddress>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAddressesPost(userKey: string, request?: PersonAddressCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAddressesPost(userKey: string, request?: PersonAddressCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAddressesPost(userKey: string, request?: PersonAddressCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAddressesPost(userKey: string, request?: PersonAddressCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAddressesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/addresses`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific alias on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete(userKey: string, personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete(userKey: string, personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete(userKey: string, personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete(userKey: string, personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific alias from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet(userKey: string, personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonAlias,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet(userKey: string, personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonAlias,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet(userKey: string, personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAlias>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet(userKey: string, personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAlias>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific alias on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAliasKey The unique person alias key.
     * @param request The patched alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch(userKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch(userKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch(userKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch(userKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific alias on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personAliasKey The unique person alias key.
     * @param request The modified alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut(userKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut(userKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut(userKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut(userKey: string, personAliasKey: string, request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesByPersonAliasKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all aliases from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonAlias>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonAlias>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAlias>>>;
    public apiNskV1UsersByUserKeyPersonAliasesGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAlias>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new alias on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonAliasesPost(userKey: string, request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonAliasesPost(userKey: string, request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonAliasesPost(userKey: string, request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonAliasesPost(userKey: string, request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonAliasesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/aliases`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific comment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personCommentKey The unique person comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete(userKey: string, personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete(userKey: string, personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete(userKey: string, personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete(userKey: string, personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific comment from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personCommentKey The unique person comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet(userKey: string, personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonComment,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet(userKey: string, personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonComment,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet(userKey: string, personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonComment>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet(userKey: string, personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonComment>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific comment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personCommentKey The unique person comment key.
     * @param request The patched comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch(userKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch(userKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch(userKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch(userKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific comment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personCommentKey The unique person comment key.
     * @param request The modified comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut(userKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut(userKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut(userKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut(userKey: string, personCommentKey: string, request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsByPersonCommentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all comments from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonComment>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonComment>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonComment>>>;
    public apiNskV1UsersByUserKeyPersonCommentsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonComment>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new comment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonCommentsPost(userKey: string, request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonCommentsPost(userKey: string, request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonCommentsPost(userKey: string, request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonCommentsPost(userKey: string, request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonCommentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/comments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific email address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personEmailAddressKey The unique person email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete(userKey: string, personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete(userKey: string, personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete(userKey: string, personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete(userKey: string, personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific email address from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personEmailAddressKey The unique person email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet(userKey: string, personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonEmail,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet(userKey: string, personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonEmail,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet(userKey: string, personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonEmail>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet(userKey: string, personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonEmail>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific email address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personEmailAddressKey The unique person email address key.
     * @param request The patched email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch(userKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch(userKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch(userKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch(userKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new email address on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personEmailAddressKey 
     * @param request The new email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost(userKey: string, personEmailAddressKey: string, request?: PersonEmailCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost(userKey: string, personEmailAddressKey: string, request?: PersonEmailCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost(userKey: string, personEmailAddressKey: string, request?: PersonEmailCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost(userKey: string, personEmailAddressKey: string, request?: PersonEmailCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific email address on the specific user&#39;s person.
     * 
     * @param userKey The specific user key.
     * @param personEmailAddressKey The unique person email address key.
     * @param request The modified email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut(userKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut(userKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut(userKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut(userKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsByPersonEmailAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all email addresses from the specific user&#39;s person.
     * 
     * @param userKey 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonEmailsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonEmail>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonEmailsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonEmail>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonEmailsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonEmail>>>;
    public apiNskV1UsersByUserKeyPersonEmailsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonEmailsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonEmail>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/emails`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the a specific user&#39;s person.
     * 
     * @param userKey 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Person,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Person,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Person>>;
    public apiNskV1UsersByUserKeyPersonGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Person>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific information on the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete(userKey: string, personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete(userKey: string, personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete(userKey: string, personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete(userKey: string, personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific information from the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet(userKey: string, personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonInformation,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet(userKey: string, personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonInformation,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet(userKey: string, personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonInformation>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet(userKey: string, personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonInformation>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific information on the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personInformationKey The unique person information key.
     * @param request The patched information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch(userKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch(userKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch(userKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch(userKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific information on the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personInformationKey The unique person information key.
     * @param request The modified information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut(userKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut(userKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut(userKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut(userKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationByPersonInformationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all information from the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonInformation>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonInformation>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonInformation>>>;
    public apiNskV1UsersByUserKeyPersonInformationGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonInformation>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new information on the logged in user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonInformationPost(userKey: string, request?: PersonInformationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonInformationPost(userKey: string, request?: PersonInformationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonInformationPost(userKey: string, request?: PersonInformationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonInformationPost(userKey: string, request?: PersonInformationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonInformationPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/information`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the specific user&#39;s person records basic information.
     * 
     * @param userKey The unique user key.
     * @param request The person patch request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPatch(userKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPatch(userKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPatch(userKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPatch(userKey: string, request?: DeltaMapperPersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific phone number on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete(userKey: string, personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete(userKey: string, personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete(userKey: string, personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete(userKey: string, personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific phone number from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet(userKey: string, personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonPhoneNumber,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet(userKey: string, personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonPhoneNumber,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet(userKey: string, personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPhoneNumber>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet(userKey: string, personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPhoneNumber>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific phone number on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The patched phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch(userKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch(userKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch(userKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch(userKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific phone number on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The modified phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut(userKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut(userKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut(userKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut(userKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersByPersonPhoneNumberKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all phone numbers from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonPhoneNumber>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonPhoneNumber>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPhoneNumber>>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPhoneNumber>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new phone number on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPhoneNumbersPost(userKey: string, request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersPost(userKey: string, request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersPost(userKey: string, request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPhoneNumbersPost(userKey: string, request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPhoneNumbersPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/phoneNumbers`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific preference for a specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete(userKey: string, personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete(userKey: string, personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete(userKey: string, personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete(userKey: string, personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific preference for a specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet(userKey: string, personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonPreference,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet(userKey: string, personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonPreference,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet(userKey: string, personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPreference>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet(userKey: string, personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPreference>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific preference for a specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPreferenceKey The unique person preference key.
     * @param request The patched preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch(userKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch(userKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch(userKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch(userKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific preference for a specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personPreferenceKey The unique person preference key.
     * @param request The modified preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut(userKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut(userKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut(userKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut(userKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesByPersonPreferenceKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all preferences for a specific user&#39;s person.
     * 
     * @param userKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonPreference>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonPreference>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPreference>>>;
    public apiNskV1UsersByUserKeyPersonPreferencesGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPreference>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new preference for a specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPreferencesPost(userKey: string, request?: PersonPreferenceCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPreferencesPost(userKey: string, request?: PersonPreferenceCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPreferencesPost(userKey: string, request?: PersonPreferenceCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPreferencesPost(userKey: string, request?: PersonPreferenceCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPreferencesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/preferences`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific program on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personProgramKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete(userKey: string, personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete(userKey: string, personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete(userKey: string, personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete(userKey: string, personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific program from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personProgramKey The unique person program key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet(userKey: string, personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonCustomerProgram,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet(userKey: string, personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonCustomerProgram,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet(userKey: string, personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonCustomerProgram>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet(userKey: string, personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonCustomerProgram>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific program on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personProgramKey The unique person program key.
     * @param request The patched program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch(userKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch(userKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch(userKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch(userKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific program on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personProgramKey The unique person program key.
     * @param request The modified program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut(userKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut(userKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut(userKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut(userKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsByPersonProgramKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all programs from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonCustomerProgram>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonCustomerProgram>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonCustomerProgram>>>;
    public apiNskV1UsersByUserKeyPersonProgramsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonCustomerProgram>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new program on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonProgramsPost(userKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonProgramsPost(userKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonProgramsPost(userKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonProgramsPost(userKey: string, request?: PersonCustomerProgramCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonProgramsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/programs`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the specific user&#39;s person record basic information.
     * 
     * @param userKey The unique user key.
     * @param request The person edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonPut(userKey: string, request?: PersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonPut(userKey: string, request?: PersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonPut(userKey: string, request?: PersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonPut(userKey: string, request?: PersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific stored payment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete(userKey: string, personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete(userKey: string, personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete(userKey: string, personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete(userKey: string, personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific stored payment from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet(userKey: string, personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonStoredPayment,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet(userKey: string, personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonStoredPayment,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet(userKey: string, personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonStoredPayment>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet(userKey: string, personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonStoredPayment>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific stored payment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The patched stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch(userKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch(userKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch(userKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch(userKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific stored payment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The modified stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut(userKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut(userKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut(userKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut(userKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsByPersonStoredPaymentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all stored payments from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonStoredPayment>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonStoredPayment>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonStoredPayment>>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonStoredPayment>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new stored payment on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonStoredPaymentsPost(userKey: string, request?: PersonStoredPaymentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsPost(userKey: string, request?: PersonStoredPaymentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsPost(userKey: string, request?: PersonStoredPaymentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonStoredPaymentsPost(userKey: string, request?: PersonStoredPaymentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonStoredPaymentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/storedPayments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific travel document on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete(userKey: string, personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete(userKey: string, personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete(userKey: string, personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete(userKey: string, personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific travel document from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet(userKey: string, personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonTravelDocument,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet(userKey: string, personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonTravelDocument,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet(userKey: string, personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonTravelDocument>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet(userKey: string, personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonTravelDocument>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all travel documents from the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelDocumentsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonTravelDocument>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonTravelDocument>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonTravelDocument>>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonTravelDocument>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelDocuments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new travel document on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param request The new travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelDocumentsPost(userKey: string, request?: PersonTravelDocumentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsPost(userKey: string, request?: PersonTravelDocumentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsPost(userKey: string, request?: PersonTravelDocumentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelDocumentsPost(userKey: string, request?: PersonTravelDocumentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelDocumentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelDocuments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete(userKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete(userKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete(userKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete(userKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification event from a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param eventType The notification event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification event for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param eventType The event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<{data:NotificationEvent,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:NotificationEvent,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationEvent>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(userKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationEvent>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification events for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet(userKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<NotificationEvent>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet(userKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<NotificationEvent>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet(userKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationEvent>>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet(userKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationEvent>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification event for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param request The notification event create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The person travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet(userKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:TravelNotification,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet(userKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:TravelNotification,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet(userKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TravelNotification>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet(userKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TravelNotification>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param request The delta mapper travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch(userKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch(userKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch(userKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch(userKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param request The travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut(userKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut(userKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut(userKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut(userKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification timed event from a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification timed event for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<{data:NotificationTimedEvent,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:NotificationTimedEvent,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationTimedEvent>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationTimedEvent>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a notification timed event for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param request The updated notification timed event request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(userKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification timed events for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(userKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<NotificationTimedEvent>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(userKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<NotificationTimedEvent>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(userKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationTimedEvent>>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(userKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationTimedEvent>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification timed event for a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param travelNotificationKey The travel notification key.
     * @param request The notification timed even create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(userKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets person travel notifications for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<TravelNotification>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<TravelNotification>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TravelNotification>>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TravelNotification>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a person travel notification for a user&#39;s person.
     * 
     * @param userKey The user key.
     * @param request The travel notification create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPersonTravelNotificationsPost(userKey: string, request?: TravelNotificationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsPost(userKey: string, request?: TravelNotificationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsPost(userKey: string, request?: TravelNotificationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPersonTravelNotificationsPost(userKey: string, request?: TravelNotificationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPersonTravelNotificationsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/person/travelNotifications`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the specific user.
     * 
     * @param userKey The unique user key.
     * @param request The user edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyPut(userKey: string, request?: UserRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyPut(userKey: string, request?: UserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyPut(userKey: string, request?: UserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyPut(userKey: string, request?: UserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delets a specific role for a specific user.
     * 
     * @param userKey The unique user key.
     * @param userRoleKey The unique user role key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete(userKey: string, userRoleKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete(userKey: string, userRoleKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete(userKey: string, userRoleKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete(userKey: string, userRoleKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete.');
        }

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles/${encodeURIComponent(String(userRoleKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific role for a specific user.
     * 
     * @param userKey The unique user key.
     * @param userRoleKey The unique user role key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyGet(userKey: string, userRoleKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:UserRole,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyGet(userKey: string, userRoleKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:UserRole,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyGet(userKey: string, userRoleKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserRole>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyGet(userKey: string, userRoleKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyGet.');
        }

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<UserRole>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles/${encodeURIComponent(String(userRoleKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific role for a specific user.
     * 
     * @param userKey The unique user key.
     * @param userRoleKey The unique user role key.
     * @param request The patched role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch(userKey: string, userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch(userKey: string, userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch(userKey: string, userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch(userKey: string, userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch.');
        }

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles/${encodeURIComponent(String(userRoleKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific role for a specific user.
     * 
     * @param userKey The unique user key.
     * @param userRoleKey The unique user role key.
     * @param request The modified role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPut(userKey: string, userRoleKey: string, request?: UserRoleEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPut(userKey: string, userRoleKey: string, request?: UserRoleEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPut(userKey: string, userRoleKey: string, request?: UserRoleEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyRolesByUserRoleKeyPut(userKey: string, userRoleKey: string, request?: UserRoleEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyPut.');
        }

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UsersByUserKeyRolesByUserRoleKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles/${encodeURIComponent(String(userRoleKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all roles for a specific user.
     * 
     * @param userKey The unique user key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesGet(userKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<UserRole>,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesGet(userKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<UserRole>,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesGet(userKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UserRole>>>;
    public apiNskV1UsersByUserKeyRolesGet(userKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<UserRole>>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new role for a specific user.
     * 
     * @param userKey The unique user key.
     * @param request The new role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersByUserKeyRolesPost(userKey: string, request?: UserRoleCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersByUserKeyRolesPost(userKey: string, request?: UserRoleCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersByUserKeyRolesPost(userKey: string, request?: UserRoleCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersByUserKeyRolesPost(userKey: string, request?: UserRoleCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV1UsersByUserKeyRolesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users/${encodeURIComponent(String(userKey))}/roles`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new user and person (used by agents to create other users).
     * This method is used by agents to create other users (either agents or customers).  Use this method when you want to create both a user and a person at the same time.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UsersPost(request?: UserCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UsersPost(request?: UserCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UsersPost(request?: UserCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UsersPost(request?: UserCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/users`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific travel document on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The patched travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch(userKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch(userKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch(userKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch(userKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v2/users/${encodeURIComponent(String(userKey))}/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific travel document on the specific user&#39;s person.
     * 
     * @param userKey The unique user key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The modified travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut(userKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut(userKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut(userKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut(userKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userKey === null || userKey === undefined) {
            throw new Error('Required parameter userKey was null or undefined when calling apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2UsersByUserKeyPersonTravelDocumentsByPersonTravelDocumentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v2/users/${encodeURIComponent(String(userKey))}/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search user records.
     * 
     * @param organizationCode The organization code to search by.
     * @param locationGroupCode The location group code to search by.
     * @param domainCode The domain code to search in.
     * @param username The unique username to search by.
     * @param usernameMatching The matching criteria for the username.
     * @param firstName The agent&#39;s first name to search by.
     * @param firstNameMatching The matching criteria for the agent&#39;s first name.
     * @param lastName The agent&#39;s last name to search by.
     * @param roleCode The role code to search with.
     * @param status The agent status to search by.
     * @param returnCount The number of results to return.
     * @param lastIndex The last user index (used for paging).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UsersGet(organizationCode?: string, locationGroupCode?: string, domainCode?: string, username?: string, usernameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', firstName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', lastName?: string, roleCode?: string, status?: 'Default' | 'Active' | 'Pending' | 'Suspended' | 'Terminated', returnCount?: number, lastIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<UserRecord>,metadata:{documentation_url:string}}>;
    public apiNskV2UsersGet(organizationCode?: string, locationGroupCode?: string, domainCode?: string, username?: string, usernameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', firstName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', lastName?: string, roleCode?: string, status?: 'Default' | 'Active' | 'Pending' | 'Suspended' | 'Terminated', returnCount?: number, lastIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<UserRecord>,metadata:{documentation_url:string}}>>;
    public apiNskV2UsersGet(organizationCode?: string, locationGroupCode?: string, domainCode?: string, username?: string, usernameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', firstName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', lastName?: string, roleCode?: string, status?: 'Default' | 'Active' | 'Pending' | 'Suspended' | 'Terminated', returnCount?: number, lastIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UserRecord>>>;
    public apiNskV2UsersGet(organizationCode?: string, locationGroupCode?: string, domainCode?: string, username?: string, usernameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', firstName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', lastName?: string, roleCode?: string, status?: 'Default' | 'Active' | 'Pending' | 'Suspended' | 'Terminated', returnCount?: number, lastIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (locationGroupCode !== undefined && locationGroupCode !== null) {
            queryParameters = queryParameters.set('LocationGroupCode', <any>locationGroupCode);
        }
        if (domainCode !== undefined && domainCode !== null) {
            queryParameters = queryParameters.set('DomainCode', <any>domainCode);
        }
        if (username !== undefined && username !== null) {
            queryParameters = queryParameters.set('Username', <any>username);
        }
        if (usernameMatching !== undefined && usernameMatching !== null) {
            queryParameters = queryParameters.set('UsernameMatching', <any>usernameMatching);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (firstNameMatching !== undefined && firstNameMatching !== null) {
            queryParameters = queryParameters.set('FirstNameMatching', <any>firstNameMatching);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (roleCode !== undefined && roleCode !== null) {
            queryParameters = queryParameters.set('RoleCode', <any>roleCode);
        }
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('Status', <any>status);
        }
        if (returnCount !== undefined && returnCount !== null) {
            queryParameters = queryParameters.set('ReturnCount', <any>returnCount);
        }
        if (lastIndex !== undefined && lastIndex !== null) {
            queryParameters = queryParameters.set('LastIndex', <any>lastIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<UserRecord>>(`${this.basePath}/api/nsk/v2/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new user for a person (used by agents to create other users).
     * This method is used by agents to create other users (either agents or customers) and connect them with an existing  person.  Use this method when a person already exists and you want to create a user for them.
     * @param request 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UsersPost(request?: UserCreateRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2UsersPost(request?: UserCreateRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2UsersPost(request?: UserCreateRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UsersPost(request?: UserCreateRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v2/users`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
