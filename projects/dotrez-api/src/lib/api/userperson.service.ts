/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Account } from '../model/account';
import { DeltaMapperPersonAddressEditRequest } from '../model/deltaMapperPersonAddressEditRequest';
import { DeltaMapperPersonAliasRequest } from '../model/deltaMapperPersonAliasRequest';
import { DeltaMapperPersonCommentRequest } from '../model/deltaMapperPersonCommentRequest';
import { DeltaMapperPersonCustomerProgramEditRequest } from '../model/deltaMapperPersonCustomerProgramEditRequest';
import { DeltaMapperPersonEditRequest } from '../model/deltaMapperPersonEditRequest';
import { DeltaMapperPersonEmailEditRequest } from '../model/deltaMapperPersonEmailEditRequest';
import { DeltaMapperPersonInformationEditRequest } from '../model/deltaMapperPersonInformationEditRequest';
import { DeltaMapperPersonPhoneNumberRequest } from '../model/deltaMapperPersonPhoneNumberRequest';
import { DeltaMapperPersonPreferenceEditRequest } from '../model/deltaMapperPersonPreferenceEditRequest';
import { DeltaMapperPersonStoredPaymentUpdateRequest } from '../model/deltaMapperPersonStoredPaymentUpdateRequest';
import { DeltaMapperTravelDocumentEditRequestv2 } from '../model/deltaMapperTravelDocumentEditRequestv2';
import { DeltaMapperTravelNotificationEditRequest } from '../model/deltaMapperTravelNotificationEditRequest';
import { IJsonResponse } from '../model/iJsonResponse';
import { NotificationEvent } from '../model/notificationEvent';
import { NotificationEventCreateRequest } from '../model/notificationEventCreateRequest';
import { NotificationTimedEvent } from '../model/notificationTimedEvent';
import { NotificationTimedEventCreateRequest } from '../model/notificationTimedEventCreateRequest';
import { NotificationTimedEventEditRequest } from '../model/notificationTimedEventEditRequest';
import { Person } from '../model/person';
import { PersonAddress } from '../model/personAddress';
import { PersonAddressCreateRequest } from '../model/personAddressCreateRequest';
import { PersonAddressEditRequest } from '../model/personAddressEditRequest';
import { PersonAlias } from '../model/personAlias';
import { PersonAliasRequest } from '../model/personAliasRequest';
import { PersonComment } from '../model/personComment';
import { PersonCommentRequest } from '../model/personCommentRequest';
import { PersonCustomerProgram } from '../model/personCustomerProgram';
import { PersonCustomerProgramCreateRequest } from '../model/personCustomerProgramCreateRequest';
import { PersonCustomerProgramEditRequest } from '../model/personCustomerProgramEditRequest';
import { PersonEditRequest } from '../model/personEditRequest';
import { PersonEmail } from '../model/personEmail';
import { PersonEmailCreateRequest } from '../model/personEmailCreateRequest';
import { PersonEmailEditRequest } from '../model/personEmailEditRequest';
import { PersonInformation } from '../model/personInformation';
import { PersonInformationCreateRequest } from '../model/personInformationCreateRequest';
import { PersonInformationEditRequest } from '../model/personInformationEditRequest';
import { PersonPhoneNumber } from '../model/personPhoneNumber';
import { PersonPhoneNumberRequest } from '../model/personPhoneNumberRequest';
import { PersonPreference } from '../model/personPreference';
import { PersonPreferenceCreateRequest } from '../model/personPreferenceCreateRequest';
import { PersonPreferenceEditRequest } from '../model/personPreferenceEditRequest';
import { PersonStoredPayment } from '../model/personStoredPayment';
import { PersonStoredPaymentRequest } from '../model/personStoredPaymentRequest';
import { PersonStoredPaymentUpdateRequest } from '../model/personStoredPaymentUpdateRequest';
import { PersonTravelDocument } from '../model/personTravelDocument';
import { PersonTravelDocumentRequest } from '../model/personTravelDocumentRequest';
import { Transaction } from '../model/transaction';
import { TravelDocumentEditRequestv2 } from '../model/travelDocumentEditRequestv2';
import { TravelNotification } from '../model/travelNotification';
import { TravelNotificationCreateRequest } from '../model/travelNotificationCreateRequest';
import { TravelNotificationEditRequest } from '../model/travelNotificationEditRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UserpersonService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieves the currently logged in person&#39;s account collection transactions.
     * 
     * @param accountCollectionKey The account collection key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Transaction>>;
    public apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1UserPersonAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/user/person/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the currently logged in person&#39;s account and collections.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAccountGet(observe?: 'body', reportProgress?: boolean): Observable<Account>;
    public apiNskV1UserPersonAccountGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
    public apiNskV1UserPersonAccountGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
    public apiNskV1UserPersonAccountGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Account>(`${this.basePath}/api/nsk/v1/user/person/account`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all transactions for all collections for the currently logged in person.
     * 
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Transaction>>;
    public apiNskV1UserPersonAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1UserPersonAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1UserPersonAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1UserPersonAccountTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1UserPersonAccountTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/user/person/account/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific address on the logged in users person.
     * 
     * @param personAddressKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesByPersonAddressKeyDelete(personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyDelete(personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyDelete(personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyDelete(personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UserPersonAddressesByPersonAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific address from the logged in users person.
     * 
     * @param personAddressKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesByPersonAddressKeyGet(personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonAddress>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyGet(personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonAddress>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyGet(personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAddress>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyGet(personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UserPersonAddressesByPersonAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAddress>(`${this.basePath}/api/nsk/v1/user/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific address on the logged in users person.
     * 
     * @param personAddressKey The unique person address key.
     * @param request The patched address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesByPersonAddressKeyPatch(personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPatch(personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPatch(personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPatch(personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UserPersonAddressesByPersonAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific address on the logged in users person.
     * 
     * @param personAddressKey The unique person address key.
     * @param request The modified address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesByPersonAddressKeyPut(personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPut(personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPut(personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAddressesByPersonAddressKeyPut(personAddressKey: string, request?: PersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1UserPersonAddressesByPersonAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all addresses from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonAddress>>;
    public apiNskV1UserPersonAddressesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonAddress>>>;
    public apiNskV1UserPersonAddressesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAddress>>>;
    public apiNskV1UserPersonAddressesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAddress>>(`${this.basePath}/api/nsk/v1/user/person/addresses`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new address on the logged in users person.
     * 
     * @param request The new address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAddressesPost(request?: PersonAddressCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAddressesPost(request?: PersonAddressCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAddressesPost(request?: PersonAddressCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAddressesPost(request?: PersonAddressCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/addresses`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific alias on the logged in users person.
     * 
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesByPersonAliasKeyDelete(personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyDelete(personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyDelete(personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyDelete(personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UserPersonAliasesByPersonAliasKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific alias from the logged in users person.
     * 
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesByPersonAliasKeyGet(personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonAlias>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyGet(personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonAlias>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyGet(personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAlias>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyGet(personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UserPersonAliasesByPersonAliasKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAlias>(`${this.basePath}/api/nsk/v1/user/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific alias on the logged in users person.
     * 
     * @param personAliasKey The unique person alias key.
     * @param request The patched alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesByPersonAliasKeyPatch(personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPatch(personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPatch(personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPatch(personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UserPersonAliasesByPersonAliasKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific alias on the logged in users person.
     * 
     * @param personAliasKey The unique person alias key.
     * @param request The modified alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesByPersonAliasKeyPut(personAliasKey: string, request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPut(personAliasKey: string, request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPut(personAliasKey: string, request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAliasesByPersonAliasKeyPut(personAliasKey: string, request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1UserPersonAliasesByPersonAliasKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all aliases from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonAlias>>;
    public apiNskV1UserPersonAliasesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonAlias>>>;
    public apiNskV1UserPersonAliasesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAlias>>>;
    public apiNskV1UserPersonAliasesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAlias>>(`${this.basePath}/api/nsk/v1/user/person/aliases`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new alias on the logged in users person.
     * 
     * @param request The new alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonAliasesPost(request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonAliasesPost(request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonAliasesPost(request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonAliasesPost(request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/aliases`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific comment on the logged in users person.
     * 
     * @param personCommentKey The unique person comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsByPersonCommentKeyDelete(personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyDelete(personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyDelete(personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyDelete(personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UserPersonCommentsByPersonCommentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific comment from the logged in users person.
     * 
     * @param personCommentKey The unique person comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsByPersonCommentKeyGet(personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonComment>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyGet(personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonComment>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyGet(personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonComment>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyGet(personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UserPersonCommentsByPersonCommentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonComment>(`${this.basePath}/api/nsk/v1/user/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific comment on the logged in users person.
     * 
     * @param personCommentKey The unique person comment key.
     * @param request The patched comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsByPersonCommentKeyPatch(personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPatch(personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPatch(personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPatch(personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UserPersonCommentsByPersonCommentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific comment on the logged in users person.
     * 
     * @param personCommentKey The unique person comment key.
     * @param request The modified comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsByPersonCommentKeyPut(personCommentKey: string, request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPut(personCommentKey: string, request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPut(personCommentKey: string, request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonCommentsByPersonCommentKeyPut(personCommentKey: string, request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1UserPersonCommentsByPersonCommentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all comments from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonComment>>;
    public apiNskV1UserPersonCommentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonComment>>>;
    public apiNskV1UserPersonCommentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonComment>>>;
    public apiNskV1UserPersonCommentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonComment>>(`${this.basePath}/api/nsk/v1/user/person/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new comment on the logged in users person.
     * 
     * @param request The new comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonCommentsPost(request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonCommentsPost(request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonCommentsPost(request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonCommentsPost(request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/comments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific email address on the logged in user&#39;s person.
     * 
     * @param personEmailAddressKey The unique person email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyDelete(personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyDelete(personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyDelete(personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyDelete(personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UserPersonEmailsByPersonEmailAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific email address from the logged in user&#39;s person.
     * 
     * @param personEmailAddressKey The unique person email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyGet(personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonEmail>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyGet(personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonEmail>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyGet(personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonEmail>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyGet(personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UserPersonEmailsByPersonEmailAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonEmail>(`${this.basePath}/api/nsk/v1/user/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific email address on the logged in user&#39;s person.
     * 
     * @param personEmailAddressKey The unique person email address key.
     * @param request The patched email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPatch(personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPatch(personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPatch(personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPatch(personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UserPersonEmailsByPersonEmailAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific email address on the logged in user&#39;s person.
     * 
     * @param personEmailAddressKey The unique person email address key.
     * @param request The modified email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPut(personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPut(personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPut(personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonEmailsByPersonEmailAddressKeyPut(personEmailAddressKey: string, request?: PersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1UserPersonEmailsByPersonEmailAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all email addresses from the logged in user&#39;s person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonEmail>>;
    public apiNskV1UserPersonEmailsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonEmail>>>;
    public apiNskV1UserPersonEmailsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonEmail>>>;
    public apiNskV1UserPersonEmailsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonEmail>>(`${this.basePath}/api/nsk/v1/user/person/emails`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new email address on the logged in user&#39;s person.
     * 
     * @param request The new email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonEmailsPost(request?: PersonEmailCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonEmailsPost(request?: PersonEmailCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonEmailsPost(request?: PersonEmailCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonEmailsPost(request?: PersonEmailCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/emails`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the current logged in person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonGet(observe?: 'body', reportProgress?: boolean): Observable<Person>;
    public apiNskV1UserPersonGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Person>>;
    public apiNskV1UserPersonGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Person>>;
    public apiNskV1UserPersonGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Person>(`${this.basePath}/api/nsk/v1/user/person`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific information on the logged in user&#39;s person.
     * 
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationByPersonInformationKeyDelete(personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonInformationByPersonInformationKeyDelete(personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyDelete(personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyDelete(personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UserPersonInformationByPersonInformationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific information from the logged in user&#39;s person.
     * 
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationByPersonInformationKeyGet(personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonInformation>;
    public apiNskV1UserPersonInformationByPersonInformationKeyGet(personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonInformation>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyGet(personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonInformation>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyGet(personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UserPersonInformationByPersonInformationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonInformation>(`${this.basePath}/api/nsk/v1/user/person/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific information on the logged in user&#39;s person.
     * 
     * @param personInformationKey The unique person information key.
     * @param request The patched information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationByPersonInformationKeyPatch(personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPatch(personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPatch(personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPatch(personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UserPersonInformationByPersonInformationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific information on the logged in user&#39;s person.
     * 
     * @param personInformationKey The unique person information key.
     * @param request The modified information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationByPersonInformationKeyPut(personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPut(personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPut(personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonInformationByPersonInformationKeyPut(personInformationKey: string, request?: PersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1UserPersonInformationByPersonInformationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all information from the logged in user&#39;s person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonInformation>>;
    public apiNskV1UserPersonInformationGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonInformation>>>;
    public apiNskV1UserPersonInformationGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonInformation>>>;
    public apiNskV1UserPersonInformationGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonInformation>>(`${this.basePath}/api/nsk/v1/user/person/information`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new information on the logged in user&#39;s person.
     * 
     * @param request The new information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonInformationPost(request?: PersonInformationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonInformationPost(request?: PersonInformationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonInformationPost(request?: PersonInformationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonInformationPost(request?: PersonInformationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/information`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the current logged in person records basic information.
     * 
     * @param request The person patch request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPatch(request?: DeltaMapperPersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPatch(request?: DeltaMapperPersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPatch(request?: DeltaMapperPersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPatch(request?: DeltaMapperPersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific phone number on the logged in users person.
     * 
     * @param personPhoneNumberKey The unique person phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyDelete(personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyDelete(personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyDelete(personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyDelete(personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific phone number from the logged in users person.
     * 
     * @param personPhoneNumberKey The unique person phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyGet(personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonPhoneNumber>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyGet(personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonPhoneNumber>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyGet(personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPhoneNumber>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyGet(personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPhoneNumber>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific phone number on the logged in users person.
     * 
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The patched phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPatch(personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPatch(personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPatch(personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPatch(personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific phone number on the logged in users person.
     * 
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The modified phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPut(personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPut(personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPut(personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPut(personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1UserPersonPhoneNumbersByPersonPhoneNumberKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all phone numbers from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonPhoneNumber>>;
    public apiNskV1UserPersonPhoneNumbersGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonPhoneNumber>>>;
    public apiNskV1UserPersonPhoneNumbersGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPhoneNumber>>>;
    public apiNskV1UserPersonPhoneNumbersGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPhoneNumber>>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new phone number on the logged in users person.
     * 
     * @param request The new phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPhoneNumbersPost(request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPhoneNumbersPost(request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersPost(request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPhoneNumbersPost(request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/phoneNumbers`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific preference on the logged in users person.
     * 
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyDelete(personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyDelete(personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyDelete(personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyDelete(personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UserPersonPreferencesByPersonPreferenceKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific preference from the logged in users person.
     * 
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyGet(personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonPreference>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyGet(personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonPreference>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyGet(personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPreference>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyGet(personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UserPersonPreferencesByPersonPreferenceKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPreference>(`${this.basePath}/api/nsk/v1/user/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific preference on the logged in users person.
     * 
     * @param personPreferenceKey The unique person preference key.
     * @param request The patched preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPatch(personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPatch(personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPatch(personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPatch(personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UserPersonPreferencesByPersonPreferenceKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific preference on the logged in users person.
     * 
     * @param personPreferenceKey The unique person preference key.
     * @param request The modified preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPut(personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPut(personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPut(personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesByPersonPreferenceKeyPut(personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1UserPersonPreferencesByPersonPreferenceKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all preferences from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonPreference>>;
    public apiNskV1UserPersonPreferencesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonPreference>>>;
    public apiNskV1UserPersonPreferencesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPreference>>>;
    public apiNskV1UserPersonPreferencesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPreference>>(`${this.basePath}/api/nsk/v1/user/person/preferences`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new preference on the logged in users person.
     * 
     * @param request The new preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPreferencesPost(request?: PersonPreferenceCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPreferencesPost(request?: PersonPreferenceCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesPost(request?: PersonPreferenceCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPreferencesPost(request?: PersonPreferenceCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/preferences`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific program on the logged in users person.
     * 
     * @param personProgramKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsByPersonProgramKeyDelete(personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyDelete(personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyDelete(personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyDelete(personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UserPersonProgramsByPersonProgramKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific program from the logged in users person.
     * 
     * @param personProgramKey The unique person program key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsByPersonProgramKeyGet(personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonCustomerProgram>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyGet(personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonCustomerProgram>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyGet(personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonCustomerProgram>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyGet(personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UserPersonProgramsByPersonProgramKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonCustomerProgram>(`${this.basePath}/api/nsk/v1/user/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific program on the logged in users person.
     * 
     * @param personProgramKey The unique person program key.
     * @param request The patched program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsByPersonProgramKeyPatch(personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPatch(personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPatch(personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPatch(personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UserPersonProgramsByPersonProgramKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific program on the logged in users person.
     * 
     * @param personProgramKey The unique person program key.
     * @param request The modified program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsByPersonProgramKeyPut(personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPut(personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPut(personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonProgramsByPersonProgramKeyPut(personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1UserPersonProgramsByPersonProgramKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all programs from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonCustomerProgram>>;
    public apiNskV1UserPersonProgramsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonCustomerProgram>>>;
    public apiNskV1UserPersonProgramsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonCustomerProgram>>>;
    public apiNskV1UserPersonProgramsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonCustomerProgram>>(`${this.basePath}/api/nsk/v1/user/person/programs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new program on the logged in users person.
     * 
     * @param request The new program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonProgramsPost(request?: PersonCustomerProgramCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonProgramsPost(request?: PersonCustomerProgramCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonProgramsPost(request?: PersonCustomerProgramCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonProgramsPost(request?: PersonCustomerProgramCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/programs`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the current logged in person record basic information.
     * 
     * @param request The person edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonPut(request?: PersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonPut(request?: PersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonPut(request?: PersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonPut(request?: PersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific stored payment on the logged in users person.
     * 
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyDelete(personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyDelete(personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyDelete(personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyDelete(personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific stored payment from the logged in users person.
     * 
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyGet(personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonStoredPayment>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyGet(personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonStoredPayment>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyGet(personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonStoredPayment>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyGet(personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonStoredPayment>(`${this.basePath}/api/nsk/v1/user/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific stored payment on the logged in users person.
     * 
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The patched stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPatch(personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPatch(personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPatch(personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPatch(personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific stored payment on the logged in users person.
     * 
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The modified stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPut(personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPut(personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPut(personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPut(personStoredPaymentKey: string, request?: PersonStoredPaymentUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1UserPersonStoredPaymentsByPersonStoredPaymentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all stored payments from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonStoredPayment>>;
    public apiNskV1UserPersonStoredPaymentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonStoredPayment>>>;
    public apiNskV1UserPersonStoredPaymentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonStoredPayment>>>;
    public apiNskV1UserPersonStoredPaymentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonStoredPayment>>(`${this.basePath}/api/nsk/v1/user/person/storedPayments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new stored payment on the logged in users person.
     * 
     * @param request The new stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonStoredPaymentsPost(request?: PersonStoredPaymentRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonStoredPaymentsPost(request?: PersonStoredPaymentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsPost(request?: PersonStoredPaymentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonStoredPaymentsPost(request?: PersonStoredPaymentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/storedPayments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific travel document on the logged in users person.
     * 
     * @param personTravelDocumentKey The unique person travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyDelete(personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyDelete(personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyDelete(personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyDelete(personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific travel document from the logged in users person.
     * 
     * @param personTravelDocumentKey The unique person travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyGet(personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<PersonTravelDocument>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyGet(personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PersonTravelDocument>>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyGet(personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonTravelDocument>>;
    public apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyGet(personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1UserPersonTravelDocumentsByPersonTravelDocumentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonTravelDocument>(`${this.basePath}/api/nsk/v1/user/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all travel documents from the logged in users person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelDocumentsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<PersonTravelDocument>>;
    public apiNskV1UserPersonTravelDocumentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonTravelDocument>>>;
    public apiNskV1UserPersonTravelDocumentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonTravelDocument>>>;
    public apiNskV1UserPersonTravelDocumentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonTravelDocument>>(`${this.basePath}/api/nsk/v1/user/person/travelDocuments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new travel document on the logged in users person.
     * 
     * @param request The new travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelDocumentsPost(request?: PersonTravelDocumentRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelDocumentsPost(request?: PersonTravelDocumentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelDocumentsPost(request?: PersonTravelDocumentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelDocumentsPost(request?: PersonTravelDocumentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelDocuments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyDelete(travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyDelete(travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyDelete(travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyDelete(travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification event from a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param eventType The notification event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification event for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param eventType The event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<NotificationEvent>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationEvent>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification events for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsGet(travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsGet(travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationEvent>>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsGet(travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationEvent>>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsGet(travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationEvent>>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification event for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param request The notification event create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsPost(travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsPost(travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsPost(travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsPost(travelNotificationKey: string, request?: NotificationEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyGet(travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<TravelNotification>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyGet(travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TravelNotification>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyGet(travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TravelNotification>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyGet(travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TravelNotification>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param request The delta mapper travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPatch(travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPatch(travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPatch(travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPatch(travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param request The travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPut(travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPut(travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPut(travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPut(travelNotificationKey: string, request?: TravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification timed event from a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification timed event for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<NotificationTimedEvent>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationTimedEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationTimedEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationTimedEvent>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a notification timed event for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param request The updated notification timed event request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification timed events for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<NotificationTimedEvent>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NotificationTimedEvent>>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationTimedEvent>>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet(travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationTimedEvent>>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification timed event for a person travel notification for the logged in user&#39;s person.
     * 
     * @param travelNotificationKey The travel notification key.
     * @param request The notification timed even create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost(travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1UserPersonTravelNotificationsByTravelNotificationKeyTimedEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets person travel notifications for the logged in user&#39;s person.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<TravelNotification>>;
    public apiNskV1UserPersonTravelNotificationsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TravelNotification>>>;
    public apiNskV1UserPersonTravelNotificationsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TravelNotification>>>;
    public apiNskV1UserPersonTravelNotificationsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TravelNotification>>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a person travel notification for the logged in user&#39;s person.
     * 
     * @param request The travel notification create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPersonTravelNotificationsPost(request?: TravelNotificationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1UserPersonTravelNotificationsPost(request?: TravelNotificationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsPost(request?: TravelNotificationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPersonTravelNotificationsPost(request?: TravelNotificationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/person/travelNotifications`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific travel document on the logged in users person.
     * 
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The patched travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPatch(personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPatch(personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPatch(personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPatch(personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v2/user/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific travel document on the logged in users person.
     * 
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The modified travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPut(personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPut(personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPut(personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPut(personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2UserPersonTravelDocumentsByPersonTravelDocumentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v2/user/person/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
