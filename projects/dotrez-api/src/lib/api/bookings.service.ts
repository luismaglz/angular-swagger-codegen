/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import {
 Account,
 AccountCollectionRequest,
 Booking,
 BookingCommentRequest,
 BookingMessageHistory,
 BookingNotificationHistory,
 BookingQueueHistory,
 BookingQueueHistoryRequest,
 BookingQueueRequest,
 BookingSearchResult,
 CheckinPassengersRequest,
 CheckinPassengersRequestv3,
 CheckinRequirements,
 CreateAccountRequest,
 FareOverrideRequest,
 HistoryResponse,
 IJsonResponse,
 InlineResponse2003,
 ItineraryQuote,
 ItineraryQuoteRequest,
 SeatAssignmentHistoryResponse,
 SegmentChangeHistoryResponse,
 Transaction,
 TransactionRequest,
} from '../types/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class BookingsService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Gets a flight move history stateless.
     * 
     * @param bookingKey The booking key.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistoryFlightMoveGet(bookingKey: string, lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:SeatAssignmentHistoryResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistoryFlightMoveGet(bookingKey: string, lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SeatAssignmentHistoryResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistoryFlightMoveGet(bookingKey: string, lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SeatAssignmentHistoryResponse>>;
    public apiNskV1BookingsByBookingKeyHistoryFlightMoveGet(bookingKey: string, lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistoryFlightMoveGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SeatAssignmentHistoryResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history/flightMove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a itinerary history stateless.
     * 
     * @param bookingKey The booking key.
     * @param event The event that triggered the history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistoryGet(bookingKey: string, event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:HistoryResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistoryGet(bookingKey: string, event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:HistoryResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistoryGet(bookingKey: string, event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HistoryResponse>>;
    public apiNskV1BookingsByBookingKeyHistoryGet(bookingKey: string, event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistoryGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<HistoryResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a booking&#39;s message history, stateless.
     * 
     * @param bookingKey The booking key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistoryMessageGet(bookingKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingMessageHistory>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistoryMessageGet(bookingKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingMessageHistory>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistoryMessageGet(bookingKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingMessageHistory>>>;
    public apiNskV1BookingsByBookingKeyHistoryMessageGet(bookingKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistoryMessageGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingMessageHistory>>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history/message`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the booking notification history, stateless.
     * 
     * @param bookingKey The booking key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistoryNotificationGet(bookingKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingNotificationHistory>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistoryNotificationGet(bookingKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingNotificationHistory>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistoryNotificationGet(bookingKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingNotificationHistory>>>;
    public apiNskV1BookingsByBookingKeyHistoryNotificationGet(bookingKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistoryNotificationGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingNotificationHistory>>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history/notification`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a seat assignment history stateless.
     * 
     * @param bookingKey The booking key.
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet(bookingKey: string, event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:SeatAssignmentHistoryResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet(bookingKey: string, event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SeatAssignmentHistoryResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet(bookingKey: string, event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SeatAssignmentHistoryResponse>>;
    public apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet(bookingKey: string, event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet.');
        }

        if (event === null || event === undefined) {
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingsByBookingKeyHistorySeatAssignmentGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SeatAssignmentHistoryResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history/seatAssignment`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a segment change history stateless.
     * 
     * @param bookingKey The booking key.
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyHistorySegmentChangeGet(bookingKey: string, event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:SegmentChangeHistoryResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyHistorySegmentChangeGet(bookingKey: string, event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SegmentChangeHistoryResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyHistorySegmentChangeGet(bookingKey: string, event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentChangeHistoryResponse>>;
    public apiNskV1BookingsByBookingKeyHistorySegmentChangeGet(bookingKey: string, event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyHistorySegmentChangeGet.');
        }

        if (event === null || event === undefined) {
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingsByBookingKeyHistorySegmentChangeGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SegmentChangeHistoryResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/history/segmentChange`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes a booking from a booking queue.
     * 
     * @param bookingKey The booking key.
     * @param request The booking request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyQueueDelete(bookingKey: string, request?: BookingQueueRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyQueueDelete(bookingKey: string, request?: BookingQueueRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyQueueDelete(bookingKey: string, request?: BookingQueueRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByBookingKeyQueueDelete(bookingKey: string, request?: BookingQueueRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyQueueDelete.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/queue`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the booking queue history for a specific booking.
     * 
     * @param bookingKey The booking key.
     * @param request The booking queue history request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyQueueHistoryPost(bookingKey: string, request?: BookingQueueHistoryRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingQueueHistory>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyQueueHistoryPost(bookingKey: string, request?: BookingQueueHistoryRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingQueueHistory>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyQueueHistoryPost(bookingKey: string, request?: BookingQueueHistoryRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingQueueHistory>>>;
    public apiNskV1BookingsByBookingKeyQueueHistoryPost(bookingKey: string, request?: BookingQueueHistoryRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyQueueHistoryPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<BookingQueueHistory>>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/queue/history`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a booking to a booking queue.
     * 
     * @param bookingKey The booking key.
     * @param request The booking request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByBookingKeyQueuePost(bookingKey: string, request?: BookingQueueRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByBookingKeyQueuePost(bookingKey: string, request?: BookingQueueRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByBookingKeyQueuePost(bookingKey: string, request?: BookingQueueRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByBookingKeyQueuePost(bookingKey: string, request?: BookingQueueRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bookingKey === null || bookingKey === undefined) {
            throw new Error('Required parameter bookingKey was null or undefined when calling apiNskV1BookingsByBookingKeyQueuePost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(bookingKey))}/queue`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the booking account collection transactions based on the record  locator, the account collection key, and the request data.
     * 
     * @param recordLocator The record locator.
     * @param accountCollectionKey The account collection key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet(recordLocator: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Transaction>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet(recordLocator: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Transaction>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet(recordLocator: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet(recordLocator: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a booking account collection transaction based on the record locator,  the account collection key, and data in the request.
     * This endpoint will add a transaction to an existing account collection.  If there are no account collections, or the account collection key does  not match an existing collection, the request will fail.                To add a new credit, see /api/nsk/v1/bookings/{recordLocator}/account/collection.
     * @param recordLocator The record locator.
     * @param accountCollectionKey The account collection key.
     * @param request The create transaction requests.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost(recordLocator: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost(recordLocator: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost(recordLocator: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost(recordLocator: string, accountCollectionKey: string, request?: TransactionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost.');
        }

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionByAccountCollectionKeyTransactionsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a booking account collection and transaction based on the record  locator and data in the request.
     * This endpoint will create a new account collection and a transaction if no collection exists or   no matching collection is found.  An account collection is unique based on the transaction code  and the expiration date.  If a matching collection is found, a transaction for that collection  is generated and the account collection will be updated.  See /api/nsk/v1/resources/accountTransactionCodes for a list of available account transaction codes.
     * @param recordLocator The record locator.
     * @param request The create account collection request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountCollectionPost(recordLocator: string, request?: AccountCollectionRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionPost(recordLocator: string, request?: AccountCollectionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionPost(recordLocator: string, request?: AccountCollectionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorAccountCollectionPost(recordLocator: string, request?: AccountCollectionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountCollectionPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account/collection`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the booking account and collections based on the record locator.
     * 
     * @param recordLocator The record locator.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountGet(recordLocator: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Account,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountGet(recordLocator: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Account,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountGet(recordLocator: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
    public apiNskV1BookingsByRecordLocatorAccountGet(recordLocator: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Account>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates the booking account based on the record locator and  data in the request.
     * 
     * @param recordLocator The record locator.
     * @param request The create account request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountPost(recordLocator: string, request?: CreateAccountRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountPost(recordLocator: string, request?: CreateAccountRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountPost(recordLocator: string, request?: CreateAccountRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorAccountPost(recordLocator: string, request?: CreateAccountRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the booking account status.
     * 
     * @param recordLocator The record locator.
     * @param status The allowed account status.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountStatusPut(recordLocator: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountStatusPut(recordLocator: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountStatusPut(recordLocator: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorAccountStatusPut(recordLocator: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountStatusPut.');
        }

        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountStatusPut.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account/status`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all of the transactions for all of the collections for the booking.
     * 
     * @param recordLocator 
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorAccountTransactionsGet(recordLocator: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Transaction>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorAccountTransactionsGet(recordLocator: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Transaction>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorAccountTransactionsGet(recordLocator: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1BookingsByRecordLocatorAccountTransactionsGet(recordLocator: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingsByRecordLocatorAccountTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/account/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a comment to a booking not in state.
     * 
     * @param recordLocator The record locator.
     * @param comments The comments to add.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorCommentsPost(recordLocator: string, comments?: Array<BookingCommentRequest>, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorCommentsPost(recordLocator: string, comments?: Array<BookingCommentRequest>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorCommentsPost(recordLocator: string, comments?: Array<BookingCommentRequest>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorCommentsPost(recordLocator: string, comments?: Array<BookingCommentRequest>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorCommentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/comments`,
            comments,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sends itinerary notification via email.
     * This method will always send itinerary notifications via email,   regardless of the chosen distributionOption on the contact.
     * @param recordLocator The record locator.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorEmailPost(recordLocator: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorEmailPost(recordLocator: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorEmailPost(recordLocator: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorEmailPost(recordLocator: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorEmailPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/email`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Replaces an existing fare price with an amount specified.
     * 
     * @param recordLocator The booking key.
     * @param journeyKey The journeyKey.
     * @param request The fare override request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: FareOverrideRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: FareOverrideRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: FareOverrideRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: FareOverrideRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingsByRecordLocatorFareOverrideJourneyByJourneyKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}/fareOverride/journey/${encodeURIComponent(String(journeyKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a booking itinerary stateless.
     * 
     * @param recordLocator The record locator.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsByRecordLocatorGet(recordLocator: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Booking,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsByRecordLocatorGet(recordLocator: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Booking,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsByRecordLocatorGet(recordLocator: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Booking>>;
    public apiNskV1BookingsByRecordLocatorGet(recordLocator: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsByRecordLocatorGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Booking>(`${this.basePath}/api/nsk/v1/bookings/${encodeURIComponent(String(recordLocator))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes the checkin status of passengers for a specific journey stateless.
     * 
     * @param recordLocator The booking record locator to look up the journey.
     * @param journeyKey The journey key.
     * @param request The checkin passengers request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyDelete.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/journey/${encodeURIComponent(String(journeyKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the checkin pre-validation requirements for a specific journey.
     * 
     * @param recordLocator The record locator of the booking.
     * @param journeyKey The journey key to be pre validate checkin with.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet(recordLocator: string, journeyKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:CheckinRequirements,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet(recordLocator: string, journeyKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:CheckinRequirements,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet(recordLocator: string, journeyKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckinRequirements>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet(recordLocator: string, journeyKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyRequirementsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CheckinRequirements>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/journey/${encodeURIComponent(String(journeyKey))}/requirements`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the passengers lift status stateless for a specific journey based on the record locator.
     * 
     * @param recordLocator The record locator in reference to the journey.
     * @param journeyKey The journey key in reference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet(recordLocator: string, journeyKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:InlineResponse2003,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet(recordLocator: string, journeyKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:InlineResponse2003,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet(recordLocator: string, journeyKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2003>>;
    public apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet(recordLocator: string, journeyKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorJourneyByJourneyKeyStatusGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2003>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/journey/${encodeURIComponent(String(journeyKey))}/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes the checkin status of passengers for a specific journey&#39;s segment stateless.
     * 
     * @param recordLocator The booking record locator to look up the journeys segment.
     * @param segmentKey The segment key.
     * @param request The checkin passengers request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete.');
        }

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyDelete.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/segment/${encodeURIComponent(String(segmentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the checkin pre-validation requirements for a specific bookings journeys segment.
     * 
     * @param recordLocator The record locator of the booking.
     * @param segmentKey The segment key to pre validate checkin with.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet(recordLocator: string, segmentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:CheckinRequirements,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet(recordLocator: string, segmentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:CheckinRequirements,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet(recordLocator: string, segmentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CheckinRequirements>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet(recordLocator: string, segmentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet.');
        }

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyRequirementsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CheckinRequirements>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/segment/${encodeURIComponent(String(segmentKey))}/requirements`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the passengers lift status stateless for a specific segment based on the record locator.
     * 
     * @param recordLocator The record locator in reference to the journey.
     * @param segmentKey The segment key in reference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet(recordLocator: string, segmentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:InlineResponse2003,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet(recordLocator: string, segmentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:InlineResponse2003,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet(recordLocator: string, segmentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2003>>;
    public apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet(recordLocator: string, segmentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet.');
        }

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingsCheckinByRecordLocatorSegmentBySegmentKeyStatusGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2003>(`${this.basePath}/api/nsk/v1/bookings/checkin/${encodeURIComponent(String(recordLocator))}/segment/${encodeURIComponent(String(segmentKey))}/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by agency.
     * 
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param firstName The first name of a passenger.
     * @param lastName The last name of a passenger.
     * @param phoneticSearch Whether or not to do a phonetic search of the last name.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByAgencyGet(organizationCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByAgencyGet(organizationCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByAgencyGet(organizationCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByAgencyGet(organizationCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (organizationCode === null || organizationCode === undefined) {
            throw new Error('Required parameter organizationCode was null or undefined when calling apiNskV1BookingsSearchByAgencyGet.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByAgency`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by the agent code.
     * 
     * @param agentCode The agent code (name) that created the booking.
     * @param domainCode The domain code to find.
     * @param firstName The first name of a passenger.
     * @param lastName The last name of a passenger.
     * @param phoneticSearch Whether or not to do a phonetic search.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByAgentCodeGet(agentCode: string, domainCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByAgentCodeGet(agentCode: string, domainCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByAgentCodeGet(agentCode: string, domainCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByAgentCodeGet(agentCode: string, domainCode: string, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (agentCode === null || agentCode === undefined) {
            throw new Error('Required parameter agentCode was null or undefined when calling apiNskV1BookingsSearchByAgentCodeGet.');
        }

        if (domainCode === null || domainCode === undefined) {
            throw new Error('Required parameter domainCode was null or undefined when calling apiNskV1BookingsSearchByAgentCodeGet.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentCode !== undefined && agentCode !== null) {
            queryParameters = queryParameters.set('AgentCode', <any>agentCode);
        }
        if (domainCode !== undefined && domainCode !== null) {
            queryParameters = queryParameters.set('DomainCode', <any>domainCode);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByAgentCode`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by agent.
     * 
     * @param agentId The agent identifier.
     * @param firstName The first name of a passenger.
     * @param lastName The last name of a passenger.
     * @param phoneticSearch Whether or not to do a phonetic search.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByAgentGet(agentId: number, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByAgentGet(agentId: number, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByAgentGet(agentId: number, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByAgentGet(agentId: number, firstName?: string, lastName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (agentId === null || agentId === undefined) {
            throw new Error('Required parameter agentId was null or undefined when calling apiNskV1BookingsSearchByAgentGet.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByAgent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by baggage tag.
     * 
     * @param bagTag One of the OS tag number.
     * @param startUtc The OS tag start date.
     * @param endUtc The OS tag end date.
     * @param pageSize The number of items to return for the request.
     * @param lastIndex The last booking index (used for paging).
     * @param searchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByBagTagGet(bagTag: string, startUtc: Date, endUtc: Date, pageSize?: number, lastIndex?: number, searchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByBagTagGet(bagTag: string, startUtc: Date, endUtc: Date, pageSize?: number, lastIndex?: number, searchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByBagTagGet(bagTag: string, startUtc: Date, endUtc: Date, pageSize?: number, lastIndex?: number, searchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByBagTagGet(bagTag: string, startUtc: Date, endUtc: Date, pageSize?: number, lastIndex?: number, searchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bagTag === null || bagTag === undefined) {
            throw new Error('Required parameter bagTag was null or undefined when calling apiNskV1BookingsSearchByBagTagGet.');
        }

        if (startUtc === null || startUtc === undefined) {
            throw new Error('Required parameter startUtc was null or undefined when calling apiNskV1BookingsSearchByBagTagGet.');
        }

        if (endUtc === null || endUtc === undefined) {
            throw new Error('Required parameter endUtc was null or undefined when calling apiNskV1BookingsSearchByBagTagGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bagTag !== undefined && bagTag !== null) {
            queryParameters = queryParameters.set('BagTag', <any>bagTag);
        }
        if (startUtc !== undefined && startUtc !== null) {
            queryParameters = queryParameters.set('StartUtc', <any>startUtc.toISOString());
        }
        if (endUtc !== undefined && endUtc !== null) {
            queryParameters = queryParameters.set('EndUtc', <any>endUtc.toISOString());
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (lastIndex !== undefined && lastIndex !== null) {
            queryParameters = queryParameters.set('LastIndex', <any>lastIndex);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByBagTag`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by contact customer number.
     * 
     * @param contactCustomerNumber One of the contacts customer number applied.
     * @param agentId The agent identifier.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByContactCustomerNumberGet(contactCustomerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByContactCustomerNumberGet(contactCustomerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByContactCustomerNumberGet(contactCustomerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByContactCustomerNumberGet(contactCustomerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (contactCustomerNumber === null || contactCustomerNumber === undefined) {
            throw new Error('Required parameter contactCustomerNumber was null or undefined when calling apiNskV1BookingsSearchByContactCustomerNumberGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contactCustomerNumber !== undefined && contactCustomerNumber !== null) {
            queryParameters = queryParameters.set('ContactCustomerNumber', <any>contactCustomerNumber);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByContactCustomerNumber`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by contact.
     * 
     * @param firstName The first name of a passenger or contact.
     * @param lastName The last name of a passenger or contact.
     * @param recordLocator Record locator being requested.
     * @param phoneNumber One of the applied phone numbers to a passenger or contact.
     * @param emailAddress The email address of a contact.
     * @param sourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param organizationGroupCode Filter by the organization group code to find.
     * @param searchArchive Whether or not to search the booking archive.
     * @param pageSize The number of items to return for the request.
     * @param lastIndex The last booking index (used for paging).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByContactGet(firstName?: string, lastName?: string, recordLocator?: string, phoneNumber?: string, emailAddress?: string, sourceOrganization?: string, organizationCode?: string, organizationGroupCode?: string, searchArchive?: boolean, pageSize?: number, lastIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByContactGet(firstName?: string, lastName?: string, recordLocator?: string, phoneNumber?: string, emailAddress?: string, sourceOrganization?: string, organizationCode?: string, organizationGroupCode?: string, searchArchive?: boolean, pageSize?: number, lastIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByContactGet(firstName?: string, lastName?: string, recordLocator?: string, phoneNumber?: string, emailAddress?: string, sourceOrganization?: string, organizationCode?: string, organizationGroupCode?: string, searchArchive?: boolean, pageSize?: number, lastIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByContactGet(firstName?: string, lastName?: string, recordLocator?: string, phoneNumber?: string, emailAddress?: string, sourceOrganization?: string, organizationCode?: string, organizationGroupCode?: string, searchArchive?: boolean, pageSize?: number, lastIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (recordLocator !== undefined && recordLocator !== null) {
            queryParameters = queryParameters.set('RecordLocator', <any>recordLocator);
        }
        if (phoneNumber !== undefined && phoneNumber !== null) {
            queryParameters = queryParameters.set('PhoneNumber', <any>phoneNumber);
        }
        if (emailAddress !== undefined && emailAddress !== null) {
            queryParameters = queryParameters.set('EmailAddress', <any>emailAddress);
        }
        if (sourceOrganization !== undefined && sourceOrganization !== null) {
            queryParameters = queryParameters.set('SourceOrganization', <any>sourceOrganization);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (organizationGroupCode !== undefined && organizationGroupCode !== null) {
            queryParameters = queryParameters.set('OrganizationGroupCode', <any>organizationGroupCode);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (lastIndex !== undefined && lastIndex !== null) {
            queryParameters = queryParameters.set('LastIndex', <any>lastIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByContact`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by credit card number.
     * 
     * @param creditCardNumber The digits of one of the credit card number applied.
     * @param agentId The agent identifier.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByCreditCardGet(creditCardNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByCreditCardGet(creditCardNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByCreditCardGet(creditCardNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByCreditCardGet(creditCardNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (creditCardNumber === null || creditCardNumber === undefined) {
            throw new Error('Required parameter creditCardNumber was null or undefined when calling apiNskV1BookingsSearchByCreditCardGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (creditCardNumber !== undefined && creditCardNumber !== null) {
            queryParameters = queryParameters.set('CreditCardNumber', <any>creditCardNumber);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByCreditCard`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by customer number.
     * 
     * @param customerNumber One of the contacts customer number applied.
     * @param agentId The agent identifier.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByCustomerNumberGet(customerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByCustomerNumberGet(customerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByCustomerNumberGet(customerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByCustomerNumberGet(customerNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (customerNumber === null || customerNumber === undefined) {
            throw new Error('Required parameter customerNumber was null or undefined when calling apiNskV1BookingsSearchByCustomerNumberGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (customerNumber !== undefined && customerNumber !== null) {
            queryParameters = queryParameters.set('CustomerNumber', <any>customerNumber);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByCustomerNumber`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by date.
     * 
     * @param startDateUtc The booking date start search.
     * @param endDateUtc The booking date end search.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByDateGet(startDateUtc: Date, endDateUtc: Date, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByDateGet(startDateUtc: Date, endDateUtc: Date, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByDateGet(startDateUtc: Date, endDateUtc: Date, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByDateGet(startDateUtc: Date, endDateUtc: Date, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (startDateUtc === null || startDateUtc === undefined) {
            throw new Error('Required parameter startDateUtc was null or undefined when calling apiNskV1BookingsSearchByDateGet.');
        }

        if (endDateUtc === null || endDateUtc === undefined) {
            throw new Error('Required parameter endDateUtc was null or undefined when calling apiNskV1BookingsSearchByDateGet.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDateUtc !== undefined && startDateUtc !== null) {
            queryParameters = queryParameters.set('StartDateUtc', <any>startDateUtc.toISOString());
        }
        if (endDateUtc !== undefined && endDateUtc !== null) {
            queryParameters = queryParameters.set('EndDateUtc', <any>endDateUtc.toISOString());
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByDate`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by document.
     * 
     * @param documentDocumentNumber One of the passengers applied travel document number.
     * @param documentDocumentTypeCode One of the passengers applied travel document type code.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByDocumentGet(documentDocumentNumber: string, documentDocumentTypeCode: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByDocumentGet(documentDocumentNumber: string, documentDocumentTypeCode: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByDocumentGet(documentDocumentNumber: string, documentDocumentTypeCode: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByDocumentGet(documentDocumentNumber: string, documentDocumentTypeCode: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (documentDocumentNumber === null || documentDocumentNumber === undefined) {
            throw new Error('Required parameter documentDocumentNumber was null or undefined when calling apiNskV1BookingsSearchByDocumentGet.');
        }

        if (documentDocumentTypeCode === null || documentDocumentTypeCode === undefined) {
            throw new Error('Required parameter documentDocumentTypeCode was null or undefined when calling apiNskV1BookingsSearchByDocumentGet.');
        }










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (documentDocumentNumber !== undefined && documentDocumentNumber !== null) {
            queryParameters = queryParameters.set('Document.DocumentNumber', <any>documentDocumentNumber);
        }
        if (documentDocumentTypeCode !== undefined && documentDocumentTypeCode !== null) {
            queryParameters = queryParameters.set('Document.DocumentTypeCode', <any>documentDocumentTypeCode);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByDocument`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by email.
     * 
     * @param emailAddress The email address of a contact.
     * @param agentId The agent identifier.
     * @param phoneticSearch Whether or not to do a phonetic search.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByEmailGet(emailAddress: string, agentId?: number, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByEmailGet(emailAddress: string, agentId?: number, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByEmailGet(emailAddress: string, agentId?: number, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByEmailGet(emailAddress: string, agentId?: number, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (emailAddress === null || emailAddress === undefined) {
            throw new Error('Required parameter emailAddress was null or undefined when calling apiNskV1BookingsSearchByEmailGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (emailAddress !== undefined && emailAddress !== null) {
            queryParameters = queryParameters.set('EmailAddress', <any>emailAddress);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByEmail`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by last name.
     * 
     * @param lastName The last name of a passenger or contact.
     * @param firstName The first name of a passenger or contact.
     * @param phoneticSearch Whether or not to do a phonetic search.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByLastNameGet(lastName: string, firstName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByLastNameGet(lastName: string, firstName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByLastNameGet(lastName: string, firstName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByLastNameGet(lastName: string, firstName?: string, phoneticSearch?: boolean, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (lastName === null || lastName === undefined) {
            throw new Error('Required parameter lastName was null or undefined when calling apiNskV1BookingsSearchByLastNameGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByLastName`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by phone.
     * 
     * @param phoneNumber One of the applied phone numbers to a passenger or contact.
     * @param agentId The agent identifier.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param filtersPageSize The number of items to return for the request.
     * @param filtersLastIndex The last booking index (used for paging).
     * @param filtersFlightNumber Filter by the flight number.
     * @param filtersDepartureDate The first journeys departure date.
     * @param filtersDestination Filter by the destination code.
     * @param filtersOrigin Filter by the departure code.
     * @param filtersSourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param filtersOrganizationGroupCode Filter by the organization group code to find.
     * @param filtersSearchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByPhoneGet(phoneNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByPhoneGet(phoneNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByPhoneGet(phoneNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByPhoneGet(phoneNumber: string, agentId?: number, organizationCode?: string, filtersPageSize?: number, filtersLastIndex?: number, filtersFlightNumber?: string, filtersDepartureDate?: Date, filtersDestination?: string, filtersOrigin?: string, filtersSourceOrganization?: string, filtersOrganizationGroupCode?: string, filtersSearchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (phoneNumber === null || phoneNumber === undefined) {
            throw new Error('Required parameter phoneNumber was null or undefined when calling apiNskV1BookingsSearchByPhoneGet.');
        }












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (phoneNumber !== undefined && phoneNumber !== null) {
            queryParameters = queryParameters.set('PhoneNumber', <any>phoneNumber);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (filtersPageSize !== undefined && filtersPageSize !== null) {
            queryParameters = queryParameters.set('Filters.PageSize', <any>filtersPageSize);
        }
        if (filtersLastIndex !== undefined && filtersLastIndex !== null) {
            queryParameters = queryParameters.set('Filters.LastIndex', <any>filtersLastIndex);
        }
        if (filtersFlightNumber !== undefined && filtersFlightNumber !== null) {
            queryParameters = queryParameters.set('Filters.FlightNumber', <any>filtersFlightNumber);
        }
        if (filtersDepartureDate !== undefined && filtersDepartureDate !== null) {
            queryParameters = queryParameters.set('Filters.DepartureDate', <any>filtersDepartureDate.toISOString());
        }
        if (filtersDestination !== undefined && filtersDestination !== null) {
            queryParameters = queryParameters.set('Filters.Destination', <any>filtersDestination);
        }
        if (filtersOrigin !== undefined && filtersOrigin !== null) {
            queryParameters = queryParameters.set('Filters.Origin', <any>filtersOrigin);
        }
        if (filtersSourceOrganization !== undefined && filtersSourceOrganization !== null) {
            queryParameters = queryParameters.set('Filters.SourceOrganization', <any>filtersSourceOrganization);
        }
        if (filtersOrganizationGroupCode !== undefined && filtersOrganizationGroupCode !== null) {
            queryParameters = queryParameters.set('Filters.OrganizationGroupCode', <any>filtersOrganizationGroupCode);
        }
        if (filtersSearchArchive !== undefined && filtersSearchArchive !== null) {
            queryParameters = queryParameters.set('Filters.SearchArchive', <any>filtersSearchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByPhone`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by record locator.
     * 
     * @param recordLocator Record locator being requested.
     * @param pageSize The number of items to return for the request.
     * @param lastIndex The last booking index (used for paging).
     * @param sourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param organizationGroupCode Filter by the organization group code to find.
     * @param searchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByRecordLocatorGet(recordLocator: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByRecordLocatorGet(recordLocator: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByRecordLocatorGet(recordLocator: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByRecordLocatorGet(recordLocator: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsSearchByRecordLocatorGet.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (recordLocator !== undefined && recordLocator !== null) {
            queryParameters = queryParameters.set('RecordLocator', <any>recordLocator);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (lastIndex !== undefined && lastIndex !== null) {
            queryParameters = queryParameters.set('LastIndex', <any>lastIndex);
        }
        if (sourceOrganization !== undefined && sourceOrganization !== null) {
            queryParameters = queryParameters.set('SourceOrganization', <any>sourceOrganization);
        }
        if (organizationGroupCode !== undefined && organizationGroupCode !== null) {
            queryParameters = queryParameters.set('OrganizationGroupCode', <any>organizationGroupCode);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByRecordLocator`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find booking by a third party record locator.
     * 
     * @param systemCode The system code to find.
     * @param recordLocator Record locator being requested.
     * @param agentId The agent identifier.
     * @param organizationCode OrganizationCode represents the organization associated with the agent who created  the booking.
     * @param pageSize The number of items to return for the request.
     * @param lastIndex The last booking index (used for paging).
     * @param sourceOrganization Filter by the organization associated with the booking. For example the  travel agency associated with this booking.
     * @param organizationGroupCode Filter by the organization group code to find.
     * @param searchArchive Whether or not to search the booking archive.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingsSearchByThirdPartyRecordLocatorGet(systemCode: string, recordLocator: string, agentId?: number, organizationCode?: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1BookingsSearchByThirdPartyRecordLocatorGet(systemCode: string, recordLocator: string, agentId?: number, organizationCode?: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1BookingsSearchByThirdPartyRecordLocatorGet(systemCode: string, recordLocator: string, agentId?: number, organizationCode?: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1BookingsSearchByThirdPartyRecordLocatorGet(systemCode: string, recordLocator: string, agentId?: number, organizationCode?: string, pageSize?: number, lastIndex?: number, sourceOrganization?: string, organizationGroupCode?: string, searchArchive?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (systemCode === null || systemCode === undefined) {
            throw new Error('Required parameter systemCode was null or undefined when calling apiNskV1BookingsSearchByThirdPartyRecordLocatorGet.');
        }

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV1BookingsSearchByThirdPartyRecordLocatorGet.');
        }








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (systemCode !== undefined && systemCode !== null) {
            queryParameters = queryParameters.set('SystemCode', <any>systemCode);
        }
        if (agentId !== undefined && agentId !== null) {
            queryParameters = queryParameters.set('AgentId', <any>agentId);
        }
        if (organizationCode !== undefined && organizationCode !== null) {
            queryParameters = queryParameters.set('OrganizationCode', <any>organizationCode);
        }
        if (recordLocator !== undefined && recordLocator !== null) {
            queryParameters = queryParameters.set('RecordLocator', <any>recordLocator);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (lastIndex !== undefined && lastIndex !== null) {
            queryParameters = queryParameters.set('LastIndex', <any>lastIndex);
        }
        if (sourceOrganization !== undefined && sourceOrganization !== null) {
            queryParameters = queryParameters.set('SourceOrganization', <any>sourceOrganization);
        }
        if (organizationGroupCode !== undefined && organizationGroupCode !== null) {
            queryParameters = queryParameters.set('OrganizationGroupCode', <any>organizationGroupCode);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/bookings/searchByThirdPartyRecordLocator`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sends itinerary notification.
     * Itinerary will be sent using the method set on the contact&#39;s distributionOption field.
     * @param recordLocator The record locator of the booking.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingsByRecordLocatorNotificationPost(recordLocator: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2BookingsByRecordLocatorNotificationPost(recordLocator: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2BookingsByRecordLocatorNotificationPost(recordLocator: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2BookingsByRecordLocatorNotificationPost(recordLocator: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV2BookingsByRecordLocatorNotificationPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v2/bookings/${encodeURIComponent(String(recordLocator))}/notification`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the booking from the New Skies server based on the retrieve booking request parameters and any configured  booking retrieve strategies. If the booking exists and the search criteria is allowed by one of the configured  booking retrieve strategies, the booking will be returned, but not loaded into the web session.
     * This endpoint will perform validation using a pre-configured booking retrieve strategy.  Custom strategies can  be configured in Utilities, and are configurable based on application name.  To set-up a custom strategy, go to Utilities -&amp;gt; Resource Management.  From the \&quot;Resource Management\&quot; screen, go  to Root -&amp;gt; Web -&amp;gt; dotREZ folder.  Right click on the dotREZ folder and select \&quot;Add Content\&quot;.  On the \&quot;Add Resource\&quot;  screen, set the \&quot;Content Name\&quot; to \&quot;BookingStrategyManagementConfig\&quot;.  Choose \&quot;XML\&quot; as the \&quot;Type\&quot;.  The \&quot;Content Data\&quot;  will be in JSON, and should look like this:  &lt;example&gt;      {      \&quot;strategies\&quot; :      [{      \&quot;applicationName\&quot; : \&quot;dotREZApi\&quot;,      \&quot;allowedStrategies\&quot; : [      \&quot;firstAndLastName\&quot;,      \&quot;email\&quot;      ]      }, {      \&quot;applicationName\&quot; : \&quot;Web\&quot;,      \&quot;allowedStrategies\&quot; : [      \&quot;email\&quot;      ]      }, {      \&quot;applicationName\&quot; : \&quot;\&quot;,      \&quot;allowedStrategies\&quot; : [      \&quot;lastName\&quot;      ]      }]      }  &lt;/example&gt;  The application name can be set when creating a new token.  If no application name is given for a token create  request, the API will use whatever value is defined in the \&quot;dotrez-nsk-common.json\&quot; configuration file under the  \&quot;systemOptions\&quot; -&amp;gt; \&quot;fallbackApplicationName\&quot;.  If no strategies are configured and no \&quot;fallbackApplicationName\&quot; is  configured, the default strategy will be a booking retrieve based on PNR, first name, and last name.  If the same strategy should be used for multiple applications, the last entry in the example above can be set by  setting an empty string as the application name, and then listing the allowed strategies to be used.  Application  specific strategies can still be defined, but if no application specific strategy is found, a list of strategies  associated with the blank application name will be used (if one exists in the configuration file).  The list of strategies currently includes the following options:  &lt;ul&gt;&lt;li&gt;          firstAndLastName      &lt;/li&gt;&lt;li&gt;          email      &lt;/li&gt;&lt;li&gt;          originAndDepartureDate      &lt;/li&gt;&lt;li&gt;          lastName      &lt;/li&gt;&lt;li&gt;          customerNumber      &lt;/li&gt;&lt;/ul&gt;  More strategies may be added in the future.
     * @param recordLocator Record locator being requested.
     * @param emailAddress The email address of a contact.
     * @param origin The origin station code.
     * @param firstName The first name of a passenger or contact.
     * @param lastName The last name of a passenger or contact.
     * @param customerNumber One of the passengers customer numbers applied.
     * @param departureDate The first journeys departure date.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingsGet(recordLocator: string, emailAddress?: string, origin?: string, firstName?: string, lastName?: string, customerNumber?: string, departureDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<{data:Booking,metadata:{documentation_url:string}}>;
    public apiNskV2BookingsGet(recordLocator: string, emailAddress?: string, origin?: string, firstName?: string, lastName?: string, customerNumber?: string, departureDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Booking,metadata:{documentation_url:string}}>>;
    public apiNskV2BookingsGet(recordLocator: string, emailAddress?: string, origin?: string, firstName?: string, lastName?: string, customerNumber?: string, departureDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Booking>>;
    public apiNskV2BookingsGet(recordLocator: string, emailAddress?: string, origin?: string, firstName?: string, lastName?: string, customerNumber?: string, departureDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV2BookingsGet.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (recordLocator !== undefined && recordLocator !== null) {
            queryParameters = queryParameters.set('RecordLocator', <any>recordLocator);
        }
        if (emailAddress !== undefined && emailAddress !== null) {
            queryParameters = queryParameters.set('EmailAddress', <any>emailAddress);
        }
        if (origin !== undefined && origin !== null) {
            queryParameters = queryParameters.set('Origin', <any>origin);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (customerNumber !== undefined && customerNumber !== null) {
            queryParameters = queryParameters.set('CustomerNumber', <any>customerNumber);
        }
        if (departureDate !== undefined && departureDate !== null) {
            queryParameters = queryParameters.set('DepartureDate', <any>departureDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Booking>(`${this.basePath}/api/nsk/v2/bookings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a itinerary quote based on the request.
     * Although this endpoint behaves like a GET, POST is used to reduce the limitations resulting from URL length issues.  Itinerary is a stateless booking and not tied to the logged in user.
     * @param request The itinerary quote request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingsQuotePost(request?: ItineraryQuoteRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:ItineraryQuote,metadata:{documentation_url:string}}>;
    public apiNskV2BookingsQuotePost(request?: ItineraryQuoteRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ItineraryQuote,metadata:{documentation_url:string}}>>;
    public apiNskV2BookingsQuotePost(request?: ItineraryQuoteRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ItineraryQuote>>;
    public apiNskV2BookingsQuotePost(request?: ItineraryQuoteRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ItineraryQuote>(`${this.basePath}/api/nsk/v2/bookings/quote`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Checks in a collection of passengers to a specific journey stateless.
     * 
     * @param recordLocator The booking record locator to look up the journey.
     * @param journeyKey The journey key of the journey to check into.
     * @param request The checkin passengers request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequestv3, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequestv3, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequestv3, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost(recordLocator: string, journeyKey: string, request?: CheckinPassengersRequestv3, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV3BookingsCheckinByRecordLocatorJourneyByJourneyKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v3/bookings/checkin/${encodeURIComponent(String(recordLocator))}/journey/${encodeURIComponent(String(journeyKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Checks in a collection of passengers to a specific journeys segment stateless.
     * 
     * @param recordLocator The booking record locator to look up the journeys segment.
     * @param segmentKey The segment key of the segment to check into.
     * @param request The checkin passengers request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequestv3, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequestv3, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequestv3, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost(recordLocator: string, segmentKey: string, request?: CheckinPassengersRequestv3, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocator === null || recordLocator === undefined) {
            throw new Error('Required parameter recordLocator was null or undefined when calling apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost.');
        }

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV3BookingsCheckinByRecordLocatorSegmentBySegmentKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v3/bookings/checkin/${encodeURIComponent(String(recordLocator))}/segment/${encodeURIComponent(String(segmentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
