/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AccountTransactionCode } from '../model/accountTransactionCode';
import { AddressType } from '../model/addressType';
import { AgentSettingType } from '../model/agentSettingType';
import { Area } from '../model/area';
import { BaggageType } from '../model/baggageType';
import { BundleApplication } from '../model/bundleApplication';
import { BundleConfiguration } from '../model/bundleConfiguration';
import { BundleRule } from '../model/bundleRule';
import { BundleSet } from '../model/bundleSet';
import { BundleSsrConfiguration } from '../model/bundleSsrConfiguration';
import { Carrier } from '../model/carrier';
import { City } from '../model/city';
import { ClassOfService } from '../model/classOfService';
import { CommerceLocation } from '../model/commerceLocation';
import { CommissionRate } from '../model/commissionRate';
import { ContactType } from '../model/contactType';
import { Countryv2 } from '../model/countryv2';
import { Culture } from '../model/culture';
import { Currency } from '../model/currency';
import { CustomerProgram } from '../model/customerProgram';
import { CustomerProgramLevel } from '../model/customerProgramLevel';
import { Delay } from '../model/delay';
import { Department } from '../model/department';
import { DocumentType } from '../model/documentType';
import { Domain } from '../model/domain';
import { DynamicParameter } from '../model/dynamicParameter';
import { EmailType } from '../model/emailType';
import { EnumResource } from '../model/enumResource';
import { ExternalRate } from '../model/externalRate';
import { FareType } from '../model/fareType';
import { Fee } from '../model/fee';
import { FeeDetail } from '../model/feeDetail';
import { HotCardReason } from '../model/hotCardReason';
import { IJsonResponse } from '../model/iJsonResponse';
import { IssuanceReason } from '../model/issuanceReason';
import { Location } from '../model/location';
import { Mac } from '../model/mac';
import { Market } from '../model/market';
import { Marketv2 } from '../model/marketv2';
import { MessageType } from '../model/messageType';
import { ParticipantType } from '../model/participantType';
import { PassengerDiscount } from '../model/passengerDiscount';
import { PassengerType } from '../model/passengerType';
import { PaymentMethod } from '../model/paymentMethod';
import { PersonAttachmentType } from '../model/personAttachmentType';
import { PersonInformationType } from '../model/personInformationType';
import { PhoneType } from '../model/phoneType';
import { ProductClass } from '../model/productClass';
import { PromotionSettingType } from '../model/promotionSettingType';
import { ProvinceState } from '../model/provinceState';
import { QueueCategory } from '../model/queueCategory';
import { ReminderTime } from '../model/reminderTime';
import { ResourceCategoryItem } from '../model/resourceCategoryItem';
import { ResourceContentItem } from '../model/resourceContentItem';
import { ResourceContentResult } from '../model/resourceContentResult';
import { ResourceEntriesCarrier } from '../model/resourceEntriesCarrier';
import { ResourceEntriesCurrencyv2 } from '../model/resourceEntriesCurrencyv2';
import { ResourceEntriesPersonAttachmentType } from '../model/resourceEntriesPersonAttachmentType';
import { ResourceEntriesStationDetail } from '../model/resourceEntriesStationDetail';
import { Role } from '../model/role';
import { RoleSettingType } from '../model/roleSettingType';
import { SettingsCategoryRequest } from '../model/settingsCategoryRequest';
import { ShoppingAttribute } from '../model/shoppingAttribute';
import { ShoppingAttributeGroup } from '../model/shoppingAttributeGroup';
import { SingleSignOnProvider } from '../model/singleSignOnProvider';
import { Source } from '../model/source';
import { Ssr } from '../model/ssr';
import { SsrGroup } from '../model/ssrGroup';
import { SsrNest } from '../model/ssrNest';
import { SsrRestrictionResult } from '../model/ssrRestrictionResult';
import { StandByPriority } from '../model/standByPriority';
import { Station } from '../model/station';
import { StationCategory } from '../model/stationCategory';
import { SubZone } from '../model/subZone';
import { Suffix } from '../model/suffix';
import { TimeZone } from '../model/timeZone';
import { Title } from '../model/title';
import { TravelClass } from '../model/travelClass';
import { Vendor } from '../model/vendor';
import { Vendorv2 } from '../model/vendorv2';
import { Zone } from '../model/zone';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class ResourcesService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieves the specific account transaction code resource.
     * 
     * @param transactionCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAccountTransactionCodesByTransactionCodeGet(transactionCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:AccountTransactionCode,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAccountTransactionCodesByTransactionCodeGet(transactionCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:AccountTransactionCode,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAccountTransactionCodesByTransactionCodeGet(transactionCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AccountTransactionCode>>;
    public apiNskV1ResourcesAccountTransactionCodesByTransactionCodeGet(transactionCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (transactionCode === null || transactionCode === undefined) {
            throw new Error('Required parameter transactionCode was null or undefined when calling apiNskV1ResourcesAccountTransactionCodesByTransactionCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AccountTransactionCode>(`${this.basePath}/api/nsk/v1/resources/AccountTransactionCodes/${encodeURIComponent(String(transactionCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of account transaction code resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAccountTransactionCodesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<AccountTransactionCode>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAccountTransactionCodesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<AccountTransactionCode>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAccountTransactionCodesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountTransactionCode>>>;
    public apiNskV1ResourcesAccountTransactionCodesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesAccountTransactionCodesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AccountTransactionCode>>(`${this.basePath}/api/nsk/v1/resources/AccountTransactionCodes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the commerce locations.
     * 
     * @param type The type of search performed (Default &#x3D; 0, Insurance &#x3D; 1, Activity &#x3D; 2, Hotel &#x3D; 3, Auto &#x3D; 4).
     * @param eTag The cache eTag for this request.
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsLocationsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<CommerceLocation>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsLocationsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<CommerceLocation>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsLocationsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CommerceLocation>>>;
    public apiNskV1ResourcesAddOnsLocationsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV1ResourcesAddOnsLocationsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CommerceLocation>>(`${this.basePath}/api/nsk/v1/resources/addOns/locations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the parameters.
     * 
     * @param type The type of search performed (Default &#x3D; 0, Insurance &#x3D; 1, Activity &#x3D; 2, Hotel &#x3D; 3, Auto &#x3D; 4).
     * @param eTag The cache eTag for this request.
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsParametersGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<DynamicParameter>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsParametersGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<DynamicParameter>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsParametersGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DynamicParameter>>>;
    public apiNskV1ResourcesAddOnsParametersGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV1ResourcesAddOnsParametersGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<DynamicParameter>>(`${this.basePath}/api/nsk/v1/resources/addOns/parameters`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the participant types.
     * 
     * @param type The type of search performed (Default &#x3D; 0, Insurance &#x3D; 1, Activity &#x3D; 2, Hotel &#x3D; 3, Auto &#x3D; 4).
     * @param eTag The cache eTag for this request.
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsParticipanttypesGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ParticipantType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsParticipanttypesGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ParticipantType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsParticipanttypesGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ParticipantType>>>;
    public apiNskV1ResourcesAddOnsParticipanttypesGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', eTag?: string, vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV1ResourcesAddOnsParticipanttypesGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ParticipantType>>(`${this.basePath}/api/nsk/v1/resources/addOns/participanttypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the sources by code.
     * 
     * @param sourceCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsSourcesBySourceCodeGet(sourceCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Source,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsSourcesBySourceCodeGet(sourceCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Source,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsSourcesBySourceCodeGet(sourceCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Source>>;
    public apiNskV1ResourcesAddOnsSourcesBySourceCodeGet(sourceCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (sourceCode === null || sourceCode === undefined) {
            throw new Error('Required parameter sourceCode was null or undefined when calling apiNskV1ResourcesAddOnsSourcesBySourceCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Source>(`${this.basePath}/api/nsk/v1/resources/addOns/sources/${encodeURIComponent(String(sourceCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the sources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsSourcesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Source>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsSourcesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Source>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsSourcesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Source>>>;
    public apiNskV1ResourcesAddOnsSourcesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesAddOnsSourcesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Source>>(`${this.basePath}/api/nsk/v1/resources/addOns/sources`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the travel commerce vendors.
     * 
     * @param type The type of search performed (Default &#x3D; 0, Insurance &#x3D; 1, Activity &#x3D; 2, Hotel &#x3D; 3, Auto &#x3D; 4).
     * @param cultureCode The specific culture code.
     * @param eTag The cache eTag for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Vendor>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Vendor>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Vendor>>>;
    public apiNskV1ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV1ResourcesAddOnsVendorsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Vendor>>(`${this.basePath}/api/nsk/v1/resources/addOns/vendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific address type resource.
     * 
     * @param addressTypeCode The unique type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddressTypesByAddressTypeCodeGet(addressTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:AddressType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddressTypesByAddressTypeCodeGet(addressTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:AddressType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddressTypesByAddressTypeCodeGet(addressTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AddressType>>;
    public apiNskV1ResourcesAddressTypesByAddressTypeCodeGet(addressTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addressTypeCode === null || addressTypeCode === undefined) {
            throw new Error('Required parameter addressTypeCode was null or undefined when calling apiNskV1ResourcesAddressTypesByAddressTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AddressType>(`${this.basePath}/api/nsk/v1/resources/AddressTypes/${encodeURIComponent(String(addressTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of address type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAddressTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<AddressType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAddressTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<AddressType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAddressTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AddressType>>>;
    public apiNskV1ResourcesAddressTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesAddressTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AddressType>>(`${this.basePath}/api/nsk/v1/resources/AddressTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific agent setting type resource.
     * 
     * @param agentSettingTypeCode The unique agent setting type code.
     * @param cultureCode The specific culture.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAgentSettingTypesByAgentSettingTypeCodeGet(agentSettingTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:AgentSettingType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAgentSettingTypesByAgentSettingTypeCodeGet(agentSettingTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:AgentSettingType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAgentSettingTypesByAgentSettingTypeCodeGet(agentSettingTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AgentSettingType>>;
    public apiNskV1ResourcesAgentSettingTypesByAgentSettingTypeCodeGet(agentSettingTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (agentSettingTypeCode === null || agentSettingTypeCode === undefined) {
            throw new Error('Required parameter agentSettingTypeCode was null or undefined when calling apiNskV1ResourcesAgentSettingTypesByAgentSettingTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AgentSettingType>(`${this.basePath}/api/nsk/v1/resources/AgentSettingTypes/${encodeURIComponent(String(agentSettingTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of agent setting type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAgentSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<AgentSettingType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAgentSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<AgentSettingType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAgentSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AgentSettingType>>>;
    public apiNskV1ResourcesAgentSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesAgentSettingTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AgentSettingType>>(`${this.basePath}/api/nsk/v1/resources/AgentSettingTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resource.
     * 
     * @param areaCode The unique area code.
     * @param cultureCode The unique culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAreasByAreaCodeGet(areaCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Area,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAreasByAreaCodeGet(areaCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Area,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAreasByAreaCodeGet(areaCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Area>>;
    public apiNskV1ResourcesAreasByAreaCodeGet(areaCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (areaCode === null || areaCode === undefined) {
            throw new Error('Required parameter areaCode was null or undefined when calling apiNskV1ResourcesAreasByAreaCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Area>(`${this.basePath}/api/nsk/v1/resources/Areas/${encodeURIComponent(String(areaCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of area resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesAreasGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Area>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesAreasGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Area>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesAreasGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Area>>>;
    public apiNskV1ResourcesAreasGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesAreasGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Area>>(`${this.basePath}/api/nsk/v1/resources/Areas`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific baggage type resource.
     * 
     * @param baggageTypeCode The unique baggage type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBaggageTypesByBaggageTypeCodeGet(baggageTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:BaggageType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBaggageTypesByBaggageTypeCodeGet(baggageTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:BaggageType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBaggageTypesByBaggageTypeCodeGet(baggageTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BaggageType>>;
    public apiNskV1ResourcesBaggageTypesByBaggageTypeCodeGet(baggageTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (baggageTypeCode === null || baggageTypeCode === undefined) {
            throw new Error('Required parameter baggageTypeCode was null or undefined when calling apiNskV1ResourcesBaggageTypesByBaggageTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BaggageType>(`${this.basePath}/api/nsk/v1/resources/BaggageTypes/${encodeURIComponent(String(baggageTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of baggage type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBaggageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BaggageType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBaggageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BaggageType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBaggageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BaggageType>>>;
    public apiNskV1ResourcesBaggageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesBaggageTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BaggageType>>(`${this.basePath}/api/nsk/v1/resources/BaggageTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of bundle application resources.
     * See api/nsk/v1/bundles/application/{bundleApplicationKey}/details to retrieve additional  bundle application details.  The application details consist of three lists: carrier codes,  product classes, and classes of service.
     * @param bundleRuleCode The bundle rule code.
     * @param cultureCode The specific culture code.
     * @param eTag The cache eTag for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesApplicationsGet(bundleRuleCode: string, cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BundleApplication>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesApplicationsGet(bundleRuleCode: string, cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BundleApplication>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesApplicationsGet(bundleRuleCode: string, cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleApplication>>>;
    public apiNskV1ResourcesBundlesApplicationsGet(bundleRuleCode: string, cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bundleRuleCode === null || bundleRuleCode === undefined) {
            throw new Error('Required parameter bundleRuleCode was null or undefined when calling apiNskV1ResourcesBundlesApplicationsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bundleRuleCode !== undefined && bundleRuleCode !== null) {
            queryParameters = queryParameters.set('BundleRuleCode', <any>bundleRuleCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundleApplication>>(`${this.basePath}/api/nsk/v1/resources/bundles/applications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific bundle configuration based on the bundle code.
     * 
     * @param bundleCode The bundle code.
     * @param cultureCode The culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesByBundleCodeGet(bundleCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:BundleConfiguration,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesByBundleCodeGet(bundleCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:BundleConfiguration,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesByBundleCodeGet(bundleCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BundleConfiguration>>;
    public apiNskV1ResourcesBundlesByBundleCodeGet(bundleCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bundleCode === null || bundleCode === undefined) {
            throw new Error('Required parameter bundleCode was null or undefined when calling apiNskV1ResourcesBundlesByBundleCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BundleConfiguration>(`${this.basePath}/api/nsk/v1/resources/bundles/${encodeURIComponent(String(bundleCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of bundle configuration resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BundleConfiguration>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BundleConfiguration>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleConfiguration>>>;
    public apiNskV1ResourcesBundlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesBundlesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundleConfiguration>>(`${this.basePath}/api/nsk/v1/resources/bundles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of bundle rule resources.
     * See api/nsk/v1/bundles/rule/{bundleRuleCode}/details to retrieve a list of bundle   applications associated with a specific bundle rule.  Bundle rules are used to control where and how bundle applications are used.
     * @param eTag The unique etag ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesRulesGet(eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BundleRule>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesRulesGet(eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BundleRule>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesRulesGet(eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleRule>>>;
    public apiNskV1ResourcesBundlesRulesGet(eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundleRule>>(`${this.basePath}/api/nsk/v1/resources/bundles/rules`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of bundle set resources.
     * See api/nsk/v1/bundles/set/{bundleSetCode}/details to retrieve a list of bundle   codes associated with a specific bundle set.
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesSetsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BundleSet>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesSetsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BundleSet>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesSetsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleSet>>>;
    public apiNskV1ResourcesBundlesSetsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesBundlesSetsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundleSet>>(`${this.basePath}/api/nsk/v1/resources/bundles/sets`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of bundle ssr configurations associated with  the bundle code.
     * 
     * @param bundleCode The bundle code.
     * @param cultureCode The specific culture code.
     * @param eTag The cache eTag for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesBundlesSsrsGet(bundleCode: string, cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BundleSsrConfiguration>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesBundlesSsrsGet(bundleCode: string, cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BundleSsrConfiguration>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesBundlesSsrsGet(bundleCode: string, cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleSsrConfiguration>>>;
    public apiNskV1ResourcesBundlesSsrsGet(bundleCode: string, cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (bundleCode === null || bundleCode === undefined) {
            throw new Error('Required parameter bundleCode was null or undefined when calling apiNskV1ResourcesBundlesSsrsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bundleCode !== undefined && bundleCode !== null) {
            queryParameters = queryParameters.set('BundleCode', <any>bundleCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundleSsrConfiguration>>(`${this.basePath}/api/nsk/v1/resources/bundles/ssrs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a single carrier.
     * 
     * @param carrierCode The unique carrier code.
     * @param cultureCode The specific culture code.
     * @param eTag The eTag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCarriersByCarrierCodeGet(carrierCode: string, cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Carrier,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCarriersByCarrierCodeGet(carrierCode: string, cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Carrier,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCarriersByCarrierCodeGet(carrierCode: string, cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Carrier>>;
    public apiNskV1ResourcesCarriersByCarrierCodeGet(carrierCode: string, cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (carrierCode === null || carrierCode === undefined) {
            throw new Error('Required parameter carrierCode was null or undefined when calling apiNskV1ResourcesCarriersByCarrierCodeGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Carrier>(`${this.basePath}/api/nsk/v1/resources/carriers/${encodeURIComponent(String(carrierCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of carrier resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCarriersGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceEntriesCarrier,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCarriersGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceEntriesCarrier,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCarriersGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceEntriesCarrier>>;
    public apiNskV1ResourcesCarriersGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesCarriersGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResourceEntriesCarrier>(`${this.basePath}/api/nsk/v1/resources/carriers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific city resource.
     * 
     * @param cityCode The unique city code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCitiesByCityCodeGet(cityCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:City,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCitiesByCityCodeGet(cityCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:City,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCitiesByCityCodeGet(cityCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<City>>;
    public apiNskV1ResourcesCitiesByCityCodeGet(cityCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling apiNskV1ResourcesCitiesByCityCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<City>(`${this.basePath}/api/nsk/v1/resources/Cities/${encodeURIComponent(String(cityCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of city resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCitiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<City>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCitiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<City>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCitiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<City>>>;
    public apiNskV1ResourcesCitiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesCitiesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<City>>(`${this.basePath}/api/nsk/v1/resources/Cities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resource.
     * 
     * @param classOfServiceCode The unique class of service code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesClassOfServicesByClassOfServiceCodeGet(classOfServiceCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ClassOfService,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesClassOfServicesByClassOfServiceCodeGet(classOfServiceCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ClassOfService,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesClassOfServicesByClassOfServiceCodeGet(classOfServiceCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ClassOfService>>;
    public apiNskV1ResourcesClassOfServicesByClassOfServiceCodeGet(classOfServiceCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (classOfServiceCode === null || classOfServiceCode === undefined) {
            throw new Error('Required parameter classOfServiceCode was null or undefined when calling apiNskV1ResourcesClassOfServicesByClassOfServiceCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ClassOfService>(`${this.basePath}/api/nsk/v1/resources/ClassOfServices/${encodeURIComponent(String(classOfServiceCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of class of service resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesClassOfServicesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ClassOfService>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesClassOfServicesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ClassOfService>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesClassOfServicesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ClassOfService>>>;
    public apiNskV1ResourcesClassOfServicesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesClassOfServicesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ClassOfService>>(`${this.basePath}/api/nsk/v1/resources/ClassOfServices`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific commission rate resource.
     * 
     * @param commissionRateCode The unique commission rate code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCommissionRatesByCommissionRateCodeGet(commissionRateCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:CommissionRate,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCommissionRatesByCommissionRateCodeGet(commissionRateCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:CommissionRate,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCommissionRatesByCommissionRateCodeGet(commissionRateCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommissionRate>>;
    public apiNskV1ResourcesCommissionRatesByCommissionRateCodeGet(commissionRateCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (commissionRateCode === null || commissionRateCode === undefined) {
            throw new Error('Required parameter commissionRateCode was null or undefined when calling apiNskV1ResourcesCommissionRatesByCommissionRateCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CommissionRate>(`${this.basePath}/api/nsk/v1/resources/CommissionRates/${encodeURIComponent(String(commissionRateCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of commission rate resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCommissionRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<CommissionRate>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCommissionRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<CommissionRate>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCommissionRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CommissionRate>>>;
    public apiNskV1ResourcesCommissionRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesCommissionRatesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CommissionRate>>(`${this.basePath}/api/nsk/v1/resources/CommissionRates`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific contact type resource.
     * 
     * @param contactTypeCode The unique contact type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesContactTypesByContactTypeCodeGet(contactTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ContactType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesContactTypesByContactTypeCodeGet(contactTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ContactType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesContactTypesByContactTypeCodeGet(contactTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ContactType>>;
    public apiNskV1ResourcesContactTypesByContactTypeCodeGet(contactTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (contactTypeCode === null || contactTypeCode === undefined) {
            throw new Error('Required parameter contactTypeCode was null or undefined when calling apiNskV1ResourcesContactTypesByContactTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ContactType>(`${this.basePath}/api/nsk/v1/resources/ContactTypes/${encodeURIComponent(String(contactTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of contact type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesContactTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ContactType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesContactTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ContactType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesContactTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ContactType>>>;
    public apiNskV1ResourcesContactTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesContactTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ContactType>>(`${this.basePath}/api/nsk/v1/resources/ContactTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves resource setting data based on the accept content type.
     * This is a post to easily allow special path characters.  If the data returned is not in HTML format and convertRtfToHtml is set to true,  the content requested was of an incompatible data type.
     * @param contentId The content id.
     * @param convertRtfToHtml The bool to determine whether or not to convert RTF to HTML data.
     * @param eTag ETag for caching.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesContentsByContentIdDataGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:string,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesContentsByContentIdDataGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:string,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesContentsByContentIdDataGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiNskV1ResourcesContentsByContentIdDataGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling apiNskV1ResourcesContentsByContentIdDataGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (convertRtfToHtml !== undefined && convertRtfToHtml !== null) {
            queryParameters = queryParameters.set('convertRtfToHtml', <any>convertRtfToHtml);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/api/nsk/v1/resources/contents/${encodeURIComponent(String(contentId))}/data`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a resource setting and its related information.
     * This is a post to easily allow special path characters.  See /resources/settings/data to avoid manually parsing the data.
     * @param contentId The content id.
     * @param convertRtfToHtml The bool to determine whether or not to convert RTF to HTML data.
     * @param eTag ETag for caching.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesContentsByContentIdGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceContentItem,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesContentsByContentIdGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceContentItem,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesContentsByContentIdGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceContentItem>>;
    public apiNskV1ResourcesContentsByContentIdGet(contentId: number, convertRtfToHtml?: boolean, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling apiNskV1ResourcesContentsByContentIdGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (convertRtfToHtml !== undefined && convertRtfToHtml !== null) {
            queryParameters = queryParameters.set('convertRtfToHtml', <any>convertRtfToHtml);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResourceContentItem>(`${this.basePath}/api/nsk/v1/resources/contents/${encodeURIComponent(String(contentId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Searches the contents based on the search criteria provided.
     * 
     * @param type Specific content type.
     * @param name Name of the content.
     * @param containerId Unique id of the container.
     * @param pageSize The default page size.
     * @param lastContentId Used to specify the last item of the page of the last set of records retrieved  when paging was performed. This is optional.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesContentsGet(type: 'GeneralReference' | 'News' | 'ConsoleHelp' | 'FareRuleReference' | 'ReviewWithCustomer' | 'Notices' | 'Literature' | 'Links' | 'Image' | 'PromotionReference' | 'SubscriptionReference', name?: string, containerId?: number, pageSize?: number, lastContentId?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ResourceContentResult>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesContentsGet(type: 'GeneralReference' | 'News' | 'ConsoleHelp' | 'FareRuleReference' | 'ReviewWithCustomer' | 'Notices' | 'Literature' | 'Links' | 'Image' | 'PromotionReference' | 'SubscriptionReference', name?: string, containerId?: number, pageSize?: number, lastContentId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ResourceContentResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesContentsGet(type: 'GeneralReference' | 'News' | 'ConsoleHelp' | 'FareRuleReference' | 'ReviewWithCustomer' | 'Notices' | 'Literature' | 'Links' | 'Image' | 'PromotionReference' | 'SubscriptionReference', name?: string, containerId?: number, pageSize?: number, lastContentId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ResourceContentResult>>>;
    public apiNskV1ResourcesContentsGet(type: 'GeneralReference' | 'News' | 'ConsoleHelp' | 'FareRuleReference' | 'ReviewWithCustomer' | 'Notices' | 'Literature' | 'Links' | 'Image' | 'PromotionReference' | 'SubscriptionReference', name?: string, containerId?: number, pageSize?: number, lastContentId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV1ResourcesContentsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('Name', <any>name);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (containerId !== undefined && containerId !== null) {
            queryParameters = queryParameters.set('ContainerId', <any>containerId);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (lastContentId !== undefined && lastContentId !== null) {
            queryParameters = queryParameters.set('LastContentId', <any>lastContentId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ResourceContentResult>>(`${this.basePath}/api/nsk/v1/resources/contents`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resource.
     * 
     * @param cultureCode The unique culure code.
     * @param forCultureCode The for culture.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCulturesByCultureCodeGet(cultureCode: string, forCultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Culture,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCulturesByCultureCodeGet(cultureCode: string, forCultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Culture,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCulturesByCultureCodeGet(cultureCode: string, forCultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Culture>>;
    public apiNskV1ResourcesCulturesByCultureCodeGet(cultureCode: string, forCultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling apiNskV1ResourcesCulturesByCultureCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forCultureCode !== undefined && forCultureCode !== null) {
            queryParameters = queryParameters.set('forCultureCode', <any>forCultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Culture>(`${this.basePath}/api/nsk/v1/resources/cultures/${encodeURIComponent(String(cultureCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCulturesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Culture>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCulturesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Culture>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCulturesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Culture>>>;
    public apiNskV1ResourcesCulturesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesCulturesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Culture>>(`${this.basePath}/api/nsk/v1/resources/cultures`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific customer program resource.
     * 
     * @param programCode The unique program code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCustomerProgramsByProgramCodeGet(programCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:CustomerProgram,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeGet(programCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:CustomerProgram,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeGet(programCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerProgram>>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeGet(programCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (programCode === null || programCode === undefined) {
            throw new Error('Required parameter programCode was null or undefined when calling apiNskV1ResourcesCustomerProgramsByProgramCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CustomerProgram>(`${this.basePath}/api/nsk/v1/resources/CustomerPrograms/${encodeURIComponent(String(programCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific program level.
     * 
     * @param programCode The unique program code.
     * @param programLevelCode The unique program level code.
     * @param cultureCode The culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet(programCode: string, programLevelCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:CustomerProgramLevel,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet(programCode: string, programLevelCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:CustomerProgramLevel,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet(programCode: string, programLevelCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerProgramLevel>>;
    public apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet(programCode: string, programLevelCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (programCode === null || programCode === undefined) {
            throw new Error('Required parameter programCode was null or undefined when calling apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet.');
        }

        if (programLevelCode === null || programLevelCode === undefined) {
            throw new Error('Required parameter programLevelCode was null or undefined when calling apiNskV1ResourcesCustomerProgramsByProgramCodeLevelsByProgramLevelCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CustomerProgramLevel>(`${this.basePath}/api/nsk/v1/resources/CustomerPrograms/${encodeURIComponent(String(programCode))}/levels/${encodeURIComponent(String(programLevelCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of customer program resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesCustomerProgramsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<CustomerProgram>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesCustomerProgramsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<CustomerProgram>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesCustomerProgramsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerProgram>>>;
    public apiNskV1ResourcesCustomerProgramsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesCustomerProgramsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CustomerProgram>>(`${this.basePath}/api/nsk/v1/resources/CustomerPrograms`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific delay resource.
     * 
     * @param delayCode The unique delay code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDelaysByDelayCodeGet(delayCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Delay,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDelaysByDelayCodeGet(delayCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Delay,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDelaysByDelayCodeGet(delayCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Delay>>;
    public apiNskV1ResourcesDelaysByDelayCodeGet(delayCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (delayCode === null || delayCode === undefined) {
            throw new Error('Required parameter delayCode was null or undefined when calling apiNskV1ResourcesDelaysByDelayCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Delay>(`${this.basePath}/api/nsk/v1/resources/Delays/${encodeURIComponent(String(delayCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of delay resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDelaysGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Delay>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDelaysGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Delay>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDelaysGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Delay>>>;
    public apiNskV1ResourcesDelaysGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesDelaysGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Delay>>(`${this.basePath}/api/nsk/v1/resources/Delays`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific department resource.
     * 
     * @param departmentCode The unique department code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDepartmentsByDepartmentCodeGet(departmentCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Department,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDepartmentsByDepartmentCodeGet(departmentCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Department,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDepartmentsByDepartmentCodeGet(departmentCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Department>>;
    public apiNskV1ResourcesDepartmentsByDepartmentCodeGet(departmentCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (departmentCode === null || departmentCode === undefined) {
            throw new Error('Required parameter departmentCode was null or undefined when calling apiNskV1ResourcesDepartmentsByDepartmentCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Department>(`${this.basePath}/api/nsk/v1/resources/Departments/${encodeURIComponent(String(departmentCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of department resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDepartmentsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Department>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDepartmentsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Department>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDepartmentsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Department>>>;
    public apiNskV1ResourcesDepartmentsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesDepartmentsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Department>>(`${this.basePath}/api/nsk/v1/resources/Departments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the localizations.
     * 
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDistributionOptionsGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<EnumResource>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDistributionOptionsGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<EnumResource>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDistributionOptionsGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<EnumResource>>>;
    public apiNskV1ResourcesDistributionOptionsGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<EnumResource>>(`${this.basePath}/api/nsk/v1/resources/distributionOptions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific document type resource.
     * 
     * @param documentTypeCode The unique document type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDocumentTypesByDocumentTypeCodeGet(documentTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:DocumentType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDocumentTypesByDocumentTypeCodeGet(documentTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:DocumentType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDocumentTypesByDocumentTypeCodeGet(documentTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DocumentType>>;
    public apiNskV1ResourcesDocumentTypesByDocumentTypeCodeGet(documentTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (documentTypeCode === null || documentTypeCode === undefined) {
            throw new Error('Required parameter documentTypeCode was null or undefined when calling apiNskV1ResourcesDocumentTypesByDocumentTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DocumentType>(`${this.basePath}/api/nsk/v1/resources/DocumentTypes/${encodeURIComponent(String(documentTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of document type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDocumentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<DocumentType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDocumentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<DocumentType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDocumentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DocumentType>>>;
    public apiNskV1ResourcesDocumentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesDocumentTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<DocumentType>>(`${this.basePath}/api/nsk/v1/resources/DocumentTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific domain resource.
     * 
     * @param domainCode The unique domain code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDomainsByDomainCodeGet(domainCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Domain,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDomainsByDomainCodeGet(domainCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Domain,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDomainsByDomainCodeGet(domainCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Domain>>;
    public apiNskV1ResourcesDomainsByDomainCodeGet(domainCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (domainCode === null || domainCode === undefined) {
            throw new Error('Required parameter domainCode was null or undefined when calling apiNskV1ResourcesDomainsByDomainCodeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Domain>(`${this.basePath}/api/nsk/v1/resources/Domains/${encodeURIComponent(String(domainCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of domain resources.
     * 
     * @param eTag The unique etag ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesDomainsGet(eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Domain>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesDomainsGet(eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Domain>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesDomainsGet(eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Domain>>>;
    public apiNskV1ResourcesDomainsGet(eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Domain>>(`${this.basePath}/api/nsk/v1/resources/Domains`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific email type resource.
     * 
     * @param emailTypeCode The unique email type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesEmailTypesByEmailTypeCodeGet(emailTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:EmailType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesEmailTypesByEmailTypeCodeGet(emailTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:EmailType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesEmailTypesByEmailTypeCodeGet(emailTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmailType>>;
    public apiNskV1ResourcesEmailTypesByEmailTypeCodeGet(emailTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (emailTypeCode === null || emailTypeCode === undefined) {
            throw new Error('Required parameter emailTypeCode was null or undefined when calling apiNskV1ResourcesEmailTypesByEmailTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<EmailType>(`${this.basePath}/api/nsk/v1/resources/EmailTypes/${encodeURIComponent(String(emailTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of email type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesEmailTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<EmailType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesEmailTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<EmailType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesEmailTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<EmailType>>>;
    public apiNskV1ResourcesEmailTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesEmailTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<EmailType>>(`${this.basePath}/api/nsk/v1/resources/EmailTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific external rate resource.
     * 
     * @param rateId The unique rate ID.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesExternalRatesByRateIdGet(rateId: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ExternalRate,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesExternalRatesByRateIdGet(rateId: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ExternalRate,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesExternalRatesByRateIdGet(rateId: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExternalRate>>;
    public apiNskV1ResourcesExternalRatesByRateIdGet(rateId: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling apiNskV1ResourcesExternalRatesByRateIdGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExternalRate>(`${this.basePath}/api/nsk/v1/resources/ExternalRates/${encodeURIComponent(String(rateId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of external rate resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesExternalRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ExternalRate>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesExternalRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ExternalRate>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesExternalRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExternalRate>>>;
    public apiNskV1ResourcesExternalRatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesExternalRatesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ExternalRate>>(`${this.basePath}/api/nsk/v1/resources/ExternalRates`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific fare type resource.
     * 
     * @param fareTypeCode The unique fare type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesFareTypesByFareTypeCodeGet(fareTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:FareType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesFareTypesByFareTypeCodeGet(fareTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:FareType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesFareTypesByFareTypeCodeGet(fareTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FareType>>;
    public apiNskV1ResourcesFareTypesByFareTypeCodeGet(fareTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fareTypeCode === null || fareTypeCode === undefined) {
            throw new Error('Required parameter fareTypeCode was null or undefined when calling apiNskV1ResourcesFareTypesByFareTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FareType>(`${this.basePath}/api/nsk/v1/resources/FareTypes/${encodeURIComponent(String(fareTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of fare type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesFareTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<FareType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesFareTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<FareType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesFareTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FareType>>>;
    public apiNskV1ResourcesFareTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesFareTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FareType>>(`${this.basePath}/api/nsk/v1/resources/FareTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the fee options.
     * Note, this endpoint is not cached like other resource endpoints.
     * @param feeCode The unique fee code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesFeesByFeeCodeDetailsGet(feeCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<FeeDetail>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesFeesByFeeCodeDetailsGet(feeCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<FeeDetail>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesFeesByFeeCodeDetailsGet(feeCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeeDetail>>>;
    public apiNskV1ResourcesFeesByFeeCodeDetailsGet(feeCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feeCode === null || feeCode === undefined) {
            throw new Error('Required parameter feeCode was null or undefined when calling apiNskV1ResourcesFeesByFeeCodeDetailsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeeDetail>>(`${this.basePath}/api/nsk/v1/resources/fees/${encodeURIComponent(String(feeCode))}/details`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific fee resource.
     * 
     * @param feeCode The unique fee code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesFeesByFeeCodeGet(feeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Fee,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesFeesByFeeCodeGet(feeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Fee,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesFeesByFeeCodeGet(feeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Fee>>;
    public apiNskV1ResourcesFeesByFeeCodeGet(feeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feeCode === null || feeCode === undefined) {
            throw new Error('Required parameter feeCode was null or undefined when calling apiNskV1ResourcesFeesByFeeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Fee>(`${this.basePath}/api/nsk/v1/resources/Fees/${encodeURIComponent(String(feeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of fee resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesFeesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Fee>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesFeesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Fee>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesFeesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Fee>>>;
    public apiNskV1ResourcesFeesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesFeesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Fee>>(`${this.basePath}/api/nsk/v1/resources/Fees`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the localizations.
     * 
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesGendersGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<EnumResource>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesGendersGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<EnumResource>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesGendersGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<EnumResource>>>;
    public apiNskV1ResourcesGendersGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<EnumResource>>(`${this.basePath}/api/nsk/v1/resources/genders`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific hot card reason resource.
     * 
     * @param hotCardReasonCode The unique hot card reason.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesHotCardReasonsByHotCardReasonCodeGet(hotCardReasonCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:HotCardReason,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesHotCardReasonsByHotCardReasonCodeGet(hotCardReasonCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:HotCardReason,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesHotCardReasonsByHotCardReasonCodeGet(hotCardReasonCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HotCardReason>>;
    public apiNskV1ResourcesHotCardReasonsByHotCardReasonCodeGet(hotCardReasonCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (hotCardReasonCode === null || hotCardReasonCode === undefined) {
            throw new Error('Required parameter hotCardReasonCode was null or undefined when calling apiNskV1ResourcesHotCardReasonsByHotCardReasonCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<HotCardReason>(`${this.basePath}/api/nsk/v1/resources/HotCardReasons/${encodeURIComponent(String(hotCardReasonCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of hot card reason resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesHotCardReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<HotCardReason>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesHotCardReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<HotCardReason>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesHotCardReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<HotCardReason>>>;
    public apiNskV1ResourcesHotCardReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesHotCardReasonsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<HotCardReason>>(`${this.basePath}/api/nsk/v1/resources/HotCardReasons`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific issuance reason resource.
     * 
     * @param issuanceReasonCode The unique issuance reason code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesIssuanceReasonsByIssuanceReasonCodeGet(issuanceReasonCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IssuanceReason,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesIssuanceReasonsByIssuanceReasonCodeGet(issuanceReasonCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IssuanceReason,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesIssuanceReasonsByIssuanceReasonCodeGet(issuanceReasonCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IssuanceReason>>;
    public apiNskV1ResourcesIssuanceReasonsByIssuanceReasonCodeGet(issuanceReasonCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (issuanceReasonCode === null || issuanceReasonCode === undefined) {
            throw new Error('Required parameter issuanceReasonCode was null or undefined when calling apiNskV1ResourcesIssuanceReasonsByIssuanceReasonCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<IssuanceReason>(`${this.basePath}/api/nsk/v1/resources/IssuanceReasons/${encodeURIComponent(String(issuanceReasonCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of issuance reason resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesIssuanceReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<IssuanceReason>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesIssuanceReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<IssuanceReason>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesIssuanceReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<IssuanceReason>>>;
    public apiNskV1ResourcesIssuanceReasonsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesIssuanceReasonsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<IssuanceReason>>(`${this.basePath}/api/nsk/v1/resources/IssuanceReasons`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific location resource.
     * 
     * @param locationCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesLocationsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Location,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesLocationsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Location,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesLocationsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Location>>;
    public apiNskV1ResourcesLocationsByLocationCodeGet(locationCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (locationCode === null || locationCode === undefined) {
            throw new Error('Required parameter locationCode was null or undefined when calling apiNskV1ResourcesLocationsByLocationCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Location>(`${this.basePath}/api/nsk/v1/resources/Locations/${encodeURIComponent(String(locationCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of location resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesLocationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Location>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesLocationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Location>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesLocationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Location>>>;
    public apiNskV1ResourcesLocationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesLocationsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Location>>(`${this.basePath}/api/nsk/v1/resources/Locations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific mac resource.
     * 
     * @param macCode The unique mac code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesMacsByMacCodeGet(macCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Mac,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesMacsByMacCodeGet(macCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Mac,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesMacsByMacCodeGet(macCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Mac>>;
    public apiNskV1ResourcesMacsByMacCodeGet(macCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (macCode === null || macCode === undefined) {
            throw new Error('Required parameter macCode was null or undefined when calling apiNskV1ResourcesMacsByMacCodeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Mac>(`${this.basePath}/api/nsk/v1/resources/Macs/${encodeURIComponent(String(macCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of mac resources.
     * 
     * @param eTag The unique etag ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesMacsGet(eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Mac>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesMacsGet(eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Mac>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesMacsGet(eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Mac>>>;
    public apiNskV1ResourcesMacsGet(eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Mac>>(`${this.basePath}/api/nsk/v1/resources/Macs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific message type resource.
     * 
     * @param messageTypeCode The unique message type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesMessageTypesByMessageTypeCodeGet(messageTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:MessageType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesMessageTypesByMessageTypeCodeGet(messageTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:MessageType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesMessageTypesByMessageTypeCodeGet(messageTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessageType>>;
    public apiNskV1ResourcesMessageTypesByMessageTypeCodeGet(messageTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (messageTypeCode === null || messageTypeCode === undefined) {
            throw new Error('Required parameter messageTypeCode was null or undefined when calling apiNskV1ResourcesMessageTypesByMessageTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<MessageType>(`${this.basePath}/api/nsk/v1/resources/MessageTypes/${encodeURIComponent(String(messageTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of message type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesMessageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<MessageType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesMessageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<MessageType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesMessageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MessageType>>>;
    public apiNskV1ResourcesMessageTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesMessageTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<MessageType>>(`${this.basePath}/api/nsk/v1/resources/MessageTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the localizations.
     * 
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesOrganizationStatusesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<EnumResource>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesOrganizationStatusesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<EnumResource>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesOrganizationStatusesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<EnumResource>>>;
    public apiNskV1ResourcesOrganizationStatusesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<EnumResource>>(`${this.basePath}/api/nsk/v1/resources/organizationStatuses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific passenger discount resource.
     * 
     * @param passengerDiscountCode The unique passenger discount code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPassengerDiscountsByPassengerDiscountCodeGet(passengerDiscountCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PassengerDiscount,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPassengerDiscountsByPassengerDiscountCodeGet(passengerDiscountCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PassengerDiscount,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPassengerDiscountsByPassengerDiscountCodeGet(passengerDiscountCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PassengerDiscount>>;
    public apiNskV1ResourcesPassengerDiscountsByPassengerDiscountCodeGet(passengerDiscountCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passengerDiscountCode === null || passengerDiscountCode === undefined) {
            throw new Error('Required parameter passengerDiscountCode was null or undefined when calling apiNskV1ResourcesPassengerDiscountsByPassengerDiscountCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PassengerDiscount>(`${this.basePath}/api/nsk/v1/resources/PassengerDiscounts/${encodeURIComponent(String(passengerDiscountCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of passenger discount resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPassengerDiscountsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PassengerDiscount>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPassengerDiscountsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PassengerDiscount>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPassengerDiscountsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PassengerDiscount>>>;
    public apiNskV1ResourcesPassengerDiscountsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPassengerDiscountsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PassengerDiscount>>(`${this.basePath}/api/nsk/v1/resources/PassengerDiscounts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific passenger type resource.
     * 
     * @param passengerTypeCode The unique passenger type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPassengerTypesByPassengerTypeCodeGet(passengerTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PassengerType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPassengerTypesByPassengerTypeCodeGet(passengerTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PassengerType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPassengerTypesByPassengerTypeCodeGet(passengerTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PassengerType>>;
    public apiNskV1ResourcesPassengerTypesByPassengerTypeCodeGet(passengerTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (passengerTypeCode === null || passengerTypeCode === undefined) {
            throw new Error('Required parameter passengerTypeCode was null or undefined when calling apiNskV1ResourcesPassengerTypesByPassengerTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PassengerType>(`${this.basePath}/api/nsk/v1/resources/PassengerTypes/${encodeURIComponent(String(passengerTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of passenger type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPassengerTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PassengerType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPassengerTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PassengerType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPassengerTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PassengerType>>>;
    public apiNskV1ResourcesPassengerTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPassengerTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PassengerType>>(`${this.basePath}/api/nsk/v1/resources/PassengerTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific payment method resource.
     * 
     * @param paymentMethodCode The unique payment method code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPaymentMethodsByPaymentMethodCodeGet(paymentMethodCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PaymentMethod,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPaymentMethodsByPaymentMethodCodeGet(paymentMethodCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PaymentMethod,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPaymentMethodsByPaymentMethodCodeGet(paymentMethodCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PaymentMethod>>;
    public apiNskV1ResourcesPaymentMethodsByPaymentMethodCodeGet(paymentMethodCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (paymentMethodCode === null || paymentMethodCode === undefined) {
            throw new Error('Required parameter paymentMethodCode was null or undefined when calling apiNskV1ResourcesPaymentMethodsByPaymentMethodCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PaymentMethod>(`${this.basePath}/api/nsk/v1/resources/PaymentMethods/${encodeURIComponent(String(paymentMethodCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of payment method resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPaymentMethodsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PaymentMethod>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPaymentMethodsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PaymentMethod>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPaymentMethodsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PaymentMethod>>>;
    public apiNskV1ResourcesPaymentMethodsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPaymentMethodsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PaymentMethod>>(`${this.basePath}/api/nsk/v1/resources/PaymentMethods`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific person attachment resource.
     * 
     * @param personAttachmentTypeCode The unique person attachment type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPersonAttachmentTypesByPersonAttachmentTypeCodeGet(personAttachmentTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonAttachmentType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPersonAttachmentTypesByPersonAttachmentTypeCodeGet(personAttachmentTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonAttachmentType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPersonAttachmentTypesByPersonAttachmentTypeCodeGet(personAttachmentTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAttachmentType>>;
    public apiNskV1ResourcesPersonAttachmentTypesByPersonAttachmentTypeCodeGet(personAttachmentTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personAttachmentTypeCode === null || personAttachmentTypeCode === undefined) {
            throw new Error('Required parameter personAttachmentTypeCode was null or undefined when calling apiNskV1ResourcesPersonAttachmentTypesByPersonAttachmentTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAttachmentType>(`${this.basePath}/api/nsk/v1/resources/PersonAttachmentTypes/${encodeURIComponent(String(personAttachmentTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of person attachment type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPersonAttachmentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceEntriesPersonAttachmentType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPersonAttachmentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceEntriesPersonAttachmentType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPersonAttachmentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceEntriesPersonAttachmentType>>;
    public apiNskV1ResourcesPersonAttachmentTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPersonAttachmentTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResourceEntriesPersonAttachmentType>(`${this.basePath}/api/nsk/v1/resources/PersonAttachmentTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific person information type resource.
     * 
     * @param personInformationTypeCode The unique person information type code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPersonInformationTypesByPersonInformationTypeCodeGet(personInformationTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonInformationType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPersonInformationTypesByPersonInformationTypeCodeGet(personInformationTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonInformationType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPersonInformationTypesByPersonInformationTypeCodeGet(personInformationTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonInformationType>>;
    public apiNskV1ResourcesPersonInformationTypesByPersonInformationTypeCodeGet(personInformationTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personInformationTypeCode === null || personInformationTypeCode === undefined) {
            throw new Error('Required parameter personInformationTypeCode was null or undefined when calling apiNskV1ResourcesPersonInformationTypesByPersonInformationTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonInformationType>(`${this.basePath}/api/nsk/v1/resources/PersonInformationTypes/${encodeURIComponent(String(personInformationTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of person information type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPersonInformationTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonInformationType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPersonInformationTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonInformationType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPersonInformationTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonInformationType>>>;
    public apiNskV1ResourcesPersonInformationTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPersonInformationTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonInformationType>>(`${this.basePath}/api/nsk/v1/resources/PersonInformationTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific phone number type resource.
     * 
     * @param phoneTypeCode The unique phone type.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPhoneTypesByPhoneTypeCodeGet(phoneTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PhoneType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPhoneTypesByPhoneTypeCodeGet(phoneTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PhoneType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPhoneTypesByPhoneTypeCodeGet(phoneTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PhoneType>>;
    public apiNskV1ResourcesPhoneTypesByPhoneTypeCodeGet(phoneTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (phoneTypeCode === null || phoneTypeCode === undefined) {
            throw new Error('Required parameter phoneTypeCode was null or undefined when calling apiNskV1ResourcesPhoneTypesByPhoneTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PhoneType>(`${this.basePath}/api/nsk/v1/resources/PhoneTypes/${encodeURIComponent(String(phoneTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of phone number type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPhoneTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PhoneType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPhoneTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PhoneType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPhoneTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PhoneType>>>;
    public apiNskV1ResourcesPhoneTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPhoneTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PhoneType>>(`${this.basePath}/api/nsk/v1/resources/PhoneTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific product class resource.
     * 
     * @param productClassCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesProductClassesByProductClassCodeGet(productClassCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ProductClass,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesProductClassesByProductClassCodeGet(productClassCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ProductClass,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesProductClassesByProductClassCodeGet(productClassCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProductClass>>;
    public apiNskV1ResourcesProductClassesByProductClassCodeGet(productClassCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (productClassCode === null || productClassCode === undefined) {
            throw new Error('Required parameter productClassCode was null or undefined when calling apiNskV1ResourcesProductClassesByProductClassCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProductClass>(`${this.basePath}/api/nsk/v1/resources/ProductClasses/${encodeURIComponent(String(productClassCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of product class resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesProductClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ProductClass>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesProductClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ProductClass>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesProductClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProductClass>>>;
    public apiNskV1ResourcesProductClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesProductClassesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ProductClass>>(`${this.basePath}/api/nsk/v1/resources/ProductClasses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific promotion setting type resource.
     * 
     * @param promotionSettingsTypeCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPromotionSettingTypesByPromotionSettingsTypeCodeGet(promotionSettingsTypeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PromotionSettingType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPromotionSettingTypesByPromotionSettingsTypeCodeGet(promotionSettingsTypeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PromotionSettingType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPromotionSettingTypesByPromotionSettingsTypeCodeGet(promotionSettingsTypeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PromotionSettingType>>;
    public apiNskV1ResourcesPromotionSettingTypesByPromotionSettingsTypeCodeGet(promotionSettingsTypeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (promotionSettingsTypeCode === null || promotionSettingsTypeCode === undefined) {
            throw new Error('Required parameter promotionSettingsTypeCode was null or undefined when calling apiNskV1ResourcesPromotionSettingTypesByPromotionSettingsTypeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PromotionSettingType>(`${this.basePath}/api/nsk/v1/resources/PromotionSettingTypes/${encodeURIComponent(String(promotionSettingsTypeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of promotion setting type resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesPromotionSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PromotionSettingType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesPromotionSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PromotionSettingType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesPromotionSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PromotionSettingType>>>;
    public apiNskV1ResourcesPromotionSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesPromotionSettingTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PromotionSettingType>>(`${this.basePath}/api/nsk/v1/resources/PromotionSettingTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific province state resource.
     * 
     * @param provinceStateCode The unique province state code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesProvinceStatesByProvinceStateCodeGet(provinceStateCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ProvinceState,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesProvinceStatesByProvinceStateCodeGet(provinceStateCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ProvinceState,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesProvinceStatesByProvinceStateCodeGet(provinceStateCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProvinceState>>;
    public apiNskV1ResourcesProvinceStatesByProvinceStateCodeGet(provinceStateCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (provinceStateCode === null || provinceStateCode === undefined) {
            throw new Error('Required parameter provinceStateCode was null or undefined when calling apiNskV1ResourcesProvinceStatesByProvinceStateCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProvinceState>(`${this.basePath}/api/nsk/v1/resources/ProvinceStates/${encodeURIComponent(String(provinceStateCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of province state resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesProvinceStatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ProvinceState>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesProvinceStatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ProvinceState>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesProvinceStatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProvinceState>>>;
    public apiNskV1ResourcesProvinceStatesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesProvinceStatesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ProvinceState>>(`${this.basePath}/api/nsk/v1/resources/ProvinceStates`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a response with a single QueueCategory that match the given parameters.
     * 
     * @param queueCategoryCode Queue Category Code being requested.
     * @param cultureCode [Optional] The culture code for the resources.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesQueueCategoriesByQueueCategoryCodeGet(queueCategoryCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:QueueCategory,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesQueueCategoriesByQueueCategoryCodeGet(queueCategoryCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:QueueCategory,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesQueueCategoriesByQueueCategoryCodeGet(queueCategoryCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<QueueCategory>>;
    public apiNskV1ResourcesQueueCategoriesByQueueCategoryCodeGet(queueCategoryCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (queueCategoryCode === null || queueCategoryCode === undefined) {
            throw new Error('Required parameter queueCategoryCode was null or undefined when calling apiNskV1ResourcesQueueCategoriesByQueueCategoryCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<QueueCategory>(`${this.basePath}/api/nsk/v1/resources/queue/categories/${encodeURIComponent(String(queueCategoryCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a response with a list of QueueCategories that match the given parameters.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesQueueCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<QueueCategory>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesQueueCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<QueueCategory>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesQueueCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<QueueCategory>>>;
    public apiNskV1ResourcesQueueCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesQueueCategoriesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<QueueCategory>>(`${this.basePath}/api/nsk/v1/resources/queue/categories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific reminder time resource that contains valid times for a passenger travel notification timed  event.
     * 
     * @param timedEventType The timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesReminderTimesByTimedEventTypeGet(timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<{data:ProvinceState,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesReminderTimesByTimedEventTypeGet(timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ProvinceState,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesReminderTimesByTimedEventTypeGet(timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProvinceState>>;
    public apiNskV1ResourcesReminderTimesByTimedEventTypeGet(timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1ResourcesReminderTimesByTimedEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ProvinceState>(`${this.basePath}/api/nsk/v1/resources/reminderTimes/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of reminder time resource that contains valid times for all passenger travel notification  timed events.
     * 
     * @param eTag The unique etag ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesReminderTimesGet(eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ReminderTime>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesReminderTimesGet(eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ReminderTime>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesReminderTimesGet(eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ReminderTime>>>;
    public apiNskV1ResourcesReminderTimesGet(eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ReminderTime>>(`${this.basePath}/api/nsk/v1/resources/reminderTimes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific role setting resource.
     * 
     * @param roleSettingTypeCode The unique role setting type code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesRoleSettingTypesByRoleSettingTypeCodeGet(roleSettingTypeCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:RoleSettingType,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesRoleSettingTypesByRoleSettingTypeCodeGet(roleSettingTypeCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:RoleSettingType,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesRoleSettingTypesByRoleSettingTypeCodeGet(roleSettingTypeCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RoleSettingType>>;
    public apiNskV1ResourcesRoleSettingTypesByRoleSettingTypeCodeGet(roleSettingTypeCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (roleSettingTypeCode === null || roleSettingTypeCode === undefined) {
            throw new Error('Required parameter roleSettingTypeCode was null or undefined when calling apiNskV1ResourcesRoleSettingTypesByRoleSettingTypeCodeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RoleSettingType>(`${this.basePath}/api/nsk/v1/resources/RoleSettingTypes/${encodeURIComponent(String(roleSettingTypeCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of role setting resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesRoleSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<RoleSettingType>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesRoleSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<RoleSettingType>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesRoleSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RoleSettingType>>>;
    public apiNskV1ResourcesRoleSettingTypesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesRoleSettingTypesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<RoleSettingType>>(`${this.basePath}/api/nsk/v1/resources/RoleSettingTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resource.
     * 
     * @param roleCode The unique role code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesRolesByRoleCodeGet(roleCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Role,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesRolesByRoleCodeGet(roleCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Role,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesRolesByRoleCodeGet(roleCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
    public apiNskV1ResourcesRolesByRoleCodeGet(roleCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (roleCode === null || roleCode === undefined) {
            throw new Error('Required parameter roleCode was null or undefined when calling apiNskV1ResourcesRolesByRoleCodeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Role>(`${this.basePath}/api/nsk/v1/resources/roles/${encodeURIComponent(String(roleCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resources.
     * 
     * @param eTag The unique etag ID.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesRolesGet(eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Role>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesRolesGet(eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Role>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesRolesGet(eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
    public apiNskV1ResourcesRolesGet(eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Role>>(`${this.basePath}/api/nsk/v1/resources/roles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the localizations.
     * 
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSearchTypesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<EnumResource>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSearchTypesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<EnumResource>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSearchTypesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<EnumResource>>>;
    public apiNskV1ResourcesSearchTypesGet(cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<EnumResource>>(`${this.basePath}/api/nsk/v1/resources/searchTypes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves resource setting data based on the accept content type.
     * This is a post to easily allow special path characters.
     * @param request The resource settings request.
     * @param eTag ETag for caching.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSettingsDataPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:string,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSettingsDataPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:string,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSettingsDataPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public apiNskV1ResourcesSettingsDataPost(request?: SettingsCategoryRequest, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/api/nsk/v1/resources/settings/data`,
            request,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a resource setting and its related information.
     * This is a post to easily allow special path characters.  See /resources/settings/data to avoid manually parsing the data.
     * @param request The resource settings request.
     * @param eTag ETag for caching.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSettingsPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceCategoryItem,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSettingsPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceCategoryItem,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSettingsPost(request?: SettingsCategoryRequest, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceCategoryItem>>;
    public apiNskV1ResourcesSettingsPost(request?: SettingsCategoryRequest, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ResourceCategoryItem>(`${this.basePath}/api/nsk/v1/resources/settings`,
            request,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific shopping attribute group resource.
     * 
     * @param shoppingAttributeGroupCode The unique shopping attribute group code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesShoppingAttributeGroupsByShoppingAttributeGroupCodeGet(shoppingAttributeGroupCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ShoppingAttributeGroup,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesShoppingAttributeGroupsByShoppingAttributeGroupCodeGet(shoppingAttributeGroupCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ShoppingAttributeGroup,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesShoppingAttributeGroupsByShoppingAttributeGroupCodeGet(shoppingAttributeGroupCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShoppingAttributeGroup>>;
    public apiNskV1ResourcesShoppingAttributeGroupsByShoppingAttributeGroupCodeGet(shoppingAttributeGroupCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shoppingAttributeGroupCode === null || shoppingAttributeGroupCode === undefined) {
            throw new Error('Required parameter shoppingAttributeGroupCode was null or undefined when calling apiNskV1ResourcesShoppingAttributeGroupsByShoppingAttributeGroupCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ShoppingAttributeGroup>(`${this.basePath}/api/nsk/v1/resources/ShoppingAttributeGroups/${encodeURIComponent(String(shoppingAttributeGroupCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of shopping attribute group resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesShoppingAttributeGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ShoppingAttributeGroup>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesShoppingAttributeGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ShoppingAttributeGroup>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesShoppingAttributeGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShoppingAttributeGroup>>>;
    public apiNskV1ResourcesShoppingAttributeGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesShoppingAttributeGroupsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ShoppingAttributeGroup>>(`${this.basePath}/api/nsk/v1/resources/ShoppingAttributeGroups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific shopping attribute resource.
     * 
     * @param shoppingAttributeCode The unique shopping attribute code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesShoppingAttributesByShoppingAttributeCodeGet(shoppingAttributeCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ShoppingAttribute,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesShoppingAttributesByShoppingAttributeCodeGet(shoppingAttributeCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ShoppingAttribute,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesShoppingAttributesByShoppingAttributeCodeGet(shoppingAttributeCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShoppingAttribute>>;
    public apiNskV1ResourcesShoppingAttributesByShoppingAttributeCodeGet(shoppingAttributeCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shoppingAttributeCode === null || shoppingAttributeCode === undefined) {
            throw new Error('Required parameter shoppingAttributeCode was null or undefined when calling apiNskV1ResourcesShoppingAttributesByShoppingAttributeCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ShoppingAttribute>(`${this.basePath}/api/nsk/v1/resources/ShoppingAttributes/${encodeURIComponent(String(shoppingAttributeCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of shopping attribute resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesShoppingAttributesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<ShoppingAttribute>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesShoppingAttributesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<ShoppingAttribute>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesShoppingAttributesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShoppingAttribute>>>;
    public apiNskV1ResourcesShoppingAttributesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesShoppingAttributesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ShoppingAttribute>>(`${this.basePath}/api/nsk/v1/resources/ShoppingAttributes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific single sign on provider.
     * 
     * @param providerName The single sign on provider name.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSingleSignOnProviderByProviderNameGet(providerName: string, observe?: 'body', reportProgress?: boolean): Observable<{data:SingleSignOnProvider,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSingleSignOnProviderByProviderNameGet(providerName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SingleSignOnProvider,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSingleSignOnProviderByProviderNameGet(providerName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SingleSignOnProvider>>;
    public apiNskV1ResourcesSingleSignOnProviderByProviderNameGet(providerName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerName === null || providerName === undefined) {
            throw new Error('Required parameter providerName was null or undefined when calling apiNskV1ResourcesSingleSignOnProviderByProviderNameGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SingleSignOnProvider>(`${this.basePath}/api/nsk/v1/resources/singleSignOnProvider/${encodeURIComponent(String(providerName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a list of available single sign on providers.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSingleSignOnProviderGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<SingleSignOnProvider>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSingleSignOnProviderGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<SingleSignOnProvider>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSingleSignOnProviderGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SingleSignOnProvider>>>;
    public apiNskV1ResourcesSingleSignOnProviderGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSingleSignOnProviderGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SingleSignOnProvider>>(`${this.basePath}/api/nsk/v1/resources/singleSignOnProvider`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific ssr group resource.
     * 
     * @param ssrGroupCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrGroupsBySsrGroupCodeGet(ssrGroupCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:SsrGroup,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrGroupsBySsrGroupCodeGet(ssrGroupCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SsrGroup,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrGroupsBySsrGroupCodeGet(ssrGroupCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SsrGroup>>;
    public apiNskV1ResourcesSsrGroupsBySsrGroupCodeGet(ssrGroupCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ssrGroupCode === null || ssrGroupCode === undefined) {
            throw new Error('Required parameter ssrGroupCode was null or undefined when calling apiNskV1ResourcesSsrGroupsBySsrGroupCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SsrGroup>(`${this.basePath}/api/nsk/v1/resources/SsrGroups/${encodeURIComponent(String(ssrGroupCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of ssr group resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<SsrGroup>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<SsrGroup>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SsrGroup>>>;
    public apiNskV1ResourcesSsrGroupsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSsrGroupsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SsrGroup>>(`${this.basePath}/api/nsk/v1/resources/SsrGroups`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific ssr nest resource.
     * 
     * @param ssrNestCode The unique ssr nest code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrNestsBySsrNestCodeGet(ssrNestCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:SsrNest,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrNestsBySsrNestCodeGet(ssrNestCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SsrNest,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrNestsBySsrNestCodeGet(ssrNestCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SsrNest>>;
    public apiNskV1ResourcesSsrNestsBySsrNestCodeGet(ssrNestCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ssrNestCode === null || ssrNestCode === undefined) {
            throw new Error('Required parameter ssrNestCode was null or undefined when calling apiNskV1ResourcesSsrNestsBySsrNestCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SsrNest>(`${this.basePath}/api/nsk/v1/resources/SsrNests/${encodeURIComponent(String(ssrNestCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of ssr nest resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrNestsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<SsrNest>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrNestsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<SsrNest>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrNestsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SsrNest>>>;
    public apiNskV1ResourcesSsrNestsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSsrNestsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SsrNest>>(`${this.basePath}/api/nsk/v1/resources/SsrNests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific ssr restriction result. resource.
     * 
     * @param ssrRestrictionResultCode The unique ssr restriction result code.
     * @param cultureCode The unique culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrRestrictionResultsBySsrRestrictionResultCodeGet(ssrRestrictionResultCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:SsrRestrictionResult,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrRestrictionResultsBySsrRestrictionResultCodeGet(ssrRestrictionResultCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SsrRestrictionResult,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrRestrictionResultsBySsrRestrictionResultCodeGet(ssrRestrictionResultCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SsrRestrictionResult>>;
    public apiNskV1ResourcesSsrRestrictionResultsBySsrRestrictionResultCodeGet(ssrRestrictionResultCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ssrRestrictionResultCode === null || ssrRestrictionResultCode === undefined) {
            throw new Error('Required parameter ssrRestrictionResultCode was null or undefined when calling apiNskV1ResourcesSsrRestrictionResultsBySsrRestrictionResultCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SsrRestrictionResult>(`${this.basePath}/api/nsk/v1/resources/SsrRestrictionResults/${encodeURIComponent(String(ssrRestrictionResultCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of ssr restriction result resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrRestrictionResultsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<SsrRestrictionResult>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrRestrictionResultsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<SsrRestrictionResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrRestrictionResultsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SsrRestrictionResult>>>;
    public apiNskV1ResourcesSsrRestrictionResultsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSsrRestrictionResultsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SsrRestrictionResult>>(`${this.basePath}/api/nsk/v1/resources/SsrRestrictionResults`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific ssr resource.
     * 
     * @param ssrCode The unique ssr code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrsBySsrCodeGet(ssrCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Ssr,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrsBySsrCodeGet(ssrCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Ssr,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrsBySsrCodeGet(ssrCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ssr>>;
    public apiNskV1ResourcesSsrsBySsrCodeGet(ssrCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ssrCode === null || ssrCode === undefined) {
            throw new Error('Required parameter ssrCode was null or undefined when calling apiNskV1ResourcesSsrsBySsrCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Ssr>(`${this.basePath}/api/nsk/v1/resources/Ssrs/${encodeURIComponent(String(ssrCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of ssr resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSsrsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Ssr>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSsrsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Ssr>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSsrsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Ssr>>>;
    public apiNskV1ResourcesSsrsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSsrsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Ssr>>(`${this.basePath}/api/nsk/v1/resources/Ssrs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific standby priority resource.
     * 
     * @param standByPriorityCode The unique standby priority code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStandByPrioritiesByStandByPriorityCodeGet(standByPriorityCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:StandByPriority,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStandByPrioritiesByStandByPriorityCodeGet(standByPriorityCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:StandByPriority,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStandByPrioritiesByStandByPriorityCodeGet(standByPriorityCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StandByPriority>>;
    public apiNskV1ResourcesStandByPrioritiesByStandByPriorityCodeGet(standByPriorityCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (standByPriorityCode === null || standByPriorityCode === undefined) {
            throw new Error('Required parameter standByPriorityCode was null or undefined when calling apiNskV1ResourcesStandByPrioritiesByStandByPriorityCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<StandByPriority>(`${this.basePath}/api/nsk/v1/resources/StandByPriorities/${encodeURIComponent(String(standByPriorityCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of standby priority resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStandByPrioritiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<StandByPriority>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStandByPrioritiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<StandByPriority>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStandByPrioritiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<StandByPriority>>>;
    public apiNskV1ResourcesStandByPrioritiesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesStandByPrioritiesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<StandByPriority>>(`${this.basePath}/api/nsk/v1/resources/StandByPriorities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific station category resource.
     * 
     * @param stationCategoryCode The unique station category code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationCategoriesByStationCategoryCodeGet(stationCategoryCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:StationCategory,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationCategoriesByStationCategoryCodeGet(stationCategoryCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:StationCategory,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationCategoriesByStationCategoryCodeGet(stationCategoryCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StationCategory>>;
    public apiNskV1ResourcesStationCategoriesByStationCategoryCodeGet(stationCategoryCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (stationCategoryCode === null || stationCategoryCode === undefined) {
            throw new Error('Required parameter stationCategoryCode was null or undefined when calling apiNskV1ResourcesStationCategoriesByStationCategoryCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<StationCategory>(`${this.basePath}/api/nsk/v1/resources/StationCategories/${encodeURIComponent(String(stationCategoryCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of station category resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<StationCategory>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<StationCategory>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<StationCategory>>>;
    public apiNskV1ResourcesStationCategoriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesStationCategoriesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<StationCategory>>(`${this.basePath}/api/nsk/v1/resources/StationCategories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the station details.
     * Note this endpoint is not cached like other resource endpoints.
     * @param stationCode The station code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationsByStationCodeDetailsGet(stationCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceEntriesStationDetail,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationsByStationCodeDetailsGet(stationCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceEntriesStationDetail,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationsByStationCodeDetailsGet(stationCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceEntriesStationDetail>>;
    public apiNskV1ResourcesStationsByStationCodeDetailsGet(stationCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (stationCode === null || stationCode === undefined) {
            throw new Error('Required parameter stationCode was null or undefined when calling apiNskV1ResourcesStationsByStationCodeDetailsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResourceEntriesStationDetail>(`${this.basePath}/api/nsk/v1/resources/stations/${encodeURIComponent(String(stationCode))}/details`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific station resource.
     * 
     * @param stationCode The unique station code.
     * @param cultureCode The specific culture code.
     * @param eTag The eTag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationsByStationCodeGet(stationCode: string, cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Station,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationsByStationCodeGet(stationCode: string, cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Station,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationsByStationCodeGet(stationCode: string, cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Station>>;
    public apiNskV1ResourcesStationsByStationCodeGet(stationCode: string, cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (stationCode === null || stationCode === undefined) {
            throw new Error('Required parameter stationCode was null or undefined when calling apiNskV1ResourcesStationsByStationCodeGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Station>(`${this.basePath}/api/nsk/v1/resources/Stations/${encodeURIComponent(String(stationCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a response with stations filtered by category.
     * This endpoint is resource intensive until cached.
     * @param stationCategoryCode 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet(stationCategoryCode: string, activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Station>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet(stationCategoryCode: string, activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Station>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet(stationCategoryCode: string, activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Station>>>;
    public apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet(stationCategoryCode: string, activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (stationCategoryCode === null || stationCategoryCode === undefined) {
            throw new Error('Required parameter stationCategoryCode was null or undefined when calling apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet.');
        }

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesStationsCategoryByStationCategoryCodeGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Station>>(`${this.basePath}/api/nsk/v1/resources/stations/category/${encodeURIComponent(String(stationCategoryCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of station resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesStationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Station>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesStationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Station>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesStationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Station>>>;
    public apiNskV1ResourcesStationsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesStationsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Station>>(`${this.basePath}/api/nsk/v1/resources/Stations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific sub zone resource.
     * 
     * @param subZoneCode The unique sub zone code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSubZonesBySubZoneCodeGet(subZoneCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:SubZone,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSubZonesBySubZoneCodeGet(subZoneCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SubZone,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSubZonesBySubZoneCodeGet(subZoneCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubZone>>;
    public apiNskV1ResourcesSubZonesBySubZoneCodeGet(subZoneCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (subZoneCode === null || subZoneCode === undefined) {
            throw new Error('Required parameter subZoneCode was null or undefined when calling apiNskV1ResourcesSubZonesBySubZoneCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SubZone>(`${this.basePath}/api/nsk/v1/resources/SubZones/${encodeURIComponent(String(subZoneCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of sub zone resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSubZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<SubZone>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSubZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<SubZone>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSubZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubZone>>>;
    public apiNskV1ResourcesSubZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSubZonesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SubZone>>(`${this.basePath}/api/nsk/v1/resources/SubZones`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific suffix resource.
     * 
     * @param suffixCode The unique suffix code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSuffixesBySuffixCodeGet(suffixCode: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Suffix,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSuffixesBySuffixCodeGet(suffixCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Suffix,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSuffixesBySuffixCodeGet(suffixCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Suffix>>;
    public apiNskV1ResourcesSuffixesBySuffixCodeGet(suffixCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (suffixCode === null || suffixCode === undefined) {
            throw new Error('Required parameter suffixCode was null or undefined when calling apiNskV1ResourcesSuffixesBySuffixCodeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Suffix>(`${this.basePath}/api/nsk/v1/resources/Suffixes/${encodeURIComponent(String(suffixCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of suffix resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesSuffixesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Suffix>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesSuffixesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Suffix>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesSuffixesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Suffix>>>;
    public apiNskV1ResourcesSuffixesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesSuffixesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Suffix>>(`${this.basePath}/api/nsk/v1/resources/Suffixes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific time zone resource.
     * 
     * @param timeZoneCode The unique time zone code.
     * @param cultureCode The specific culture code.
     * @param eTag The eTag.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTimeZonesByTimeZoneCodeGet(timeZoneCode: string, cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:TimeZone,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTimeZonesByTimeZoneCodeGet(timeZoneCode: string, cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:TimeZone,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTimeZonesByTimeZoneCodeGet(timeZoneCode: string, cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TimeZone>>;
    public apiNskV1ResourcesTimeZonesByTimeZoneCodeGet(timeZoneCode: string, cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (timeZoneCode === null || timeZoneCode === undefined) {
            throw new Error('Required parameter timeZoneCode was null or undefined when calling apiNskV1ResourcesTimeZonesByTimeZoneCodeGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('eTag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TimeZone>(`${this.basePath}/api/nsk/v1/resources/TimeZones/${encodeURIComponent(String(timeZoneCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of time zone resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTimeZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<TimeZone>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTimeZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<TimeZone>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTimeZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TimeZone>>>;
    public apiNskV1ResourcesTimeZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesTimeZonesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TimeZone>>(`${this.basePath}/api/nsk/v1/resources/TimeZones`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific title resource.
     * 
     * @param titleKey The unique title key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTitlesByTitleKeyGet(titleKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Title,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTitlesByTitleKeyGet(titleKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Title,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTitlesByTitleKeyGet(titleKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Title>>;
    public apiNskV1ResourcesTitlesByTitleKeyGet(titleKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (titleKey === null || titleKey === undefined) {
            throw new Error('Required parameter titleKey was null or undefined when calling apiNskV1ResourcesTitlesByTitleKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Title>(`${this.basePath}/api/nsk/v1/resources/Titles/${encodeURIComponent(String(titleKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of title resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTitlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Title>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTitlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Title>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTitlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Title>>>;
    public apiNskV1ResourcesTitlesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesTitlesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Title>>(`${this.basePath}/api/nsk/v1/resources/Titles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific travel class resource.
     * 
     * @param travelClassCode The unique travel class code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTravelClassesByTravelClassCodeGet(travelClassCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:TravelClass,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTravelClassesByTravelClassCodeGet(travelClassCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:TravelClass,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTravelClassesByTravelClassCodeGet(travelClassCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TravelClass>>;
    public apiNskV1ResourcesTravelClassesByTravelClassCodeGet(travelClassCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (travelClassCode === null || travelClassCode === undefined) {
            throw new Error('Required parameter travelClassCode was null or undefined when calling apiNskV1ResourcesTravelClassesByTravelClassCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TravelClass>(`${this.basePath}/api/nsk/v1/resources/TravelClasses/${encodeURIComponent(String(travelClassCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of travel class resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesTravelClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<TravelClass>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesTravelClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<TravelClass>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesTravelClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TravelClass>>>;
    public apiNskV1ResourcesTravelClassesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesTravelClassesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TravelClass>>(`${this.basePath}/api/nsk/v1/resources/TravelClasses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific zone resource.
     * 
     * @param zoneCode The unique zone code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesZonesByZoneCodeGet(zoneCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Zone,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesZonesByZoneCodeGet(zoneCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Zone,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesZonesByZoneCodeGet(zoneCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Zone>>;
    public apiNskV1ResourcesZonesByZoneCodeGet(zoneCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (zoneCode === null || zoneCode === undefined) {
            throw new Error('Required parameter zoneCode was null or undefined when calling apiNskV1ResourcesZonesByZoneCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Zone>(`${this.basePath}/api/nsk/v1/resources/Zones/${encodeURIComponent(String(zoneCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of zone resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1ResourcesZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Zone>,metadata:{documentation_url:string}}>;
    public apiNskV1ResourcesZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Zone>,metadata:{documentation_url:string}}>>;
    public apiNskV1ResourcesZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Zone>>>;
    public apiNskV1ResourcesZonesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1ResourcesZonesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Zone>>(`${this.basePath}/api/nsk/v1/resources/Zones`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the travel commerce vendors.
     * 
     * @param type The type of search performed (Default &#x3D; 0, Insurance &#x3D; 1, Activity &#x3D; 2, Hotel &#x3D; 3, Auto &#x3D; 4).
     * @param cultureCode The specific culture code.
     * @param eTag The cache eTag for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Vendorv2>,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Vendorv2>,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Vendorv2>>>;
    public apiNskV2ResourcesAddOnsVendorsGet(type: 'Default' | 'Insurance' | 'Activity' | 'Hotel' | 'Car', cultureCode?: string, eTag?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling apiNskV2ResourcesAddOnsVendorsGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Vendorv2>>(`${this.basePath}/api/nsk/v2/resources/addOns/vendors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific country resource.
     * 
     * @param countryCode The unique country code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesCountriesByCountryCodeGet(countryCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Countryv2,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesCountriesByCountryCodeGet(countryCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Countryv2,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesCountriesByCountryCodeGet(countryCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Countryv2>>;
    public apiNskV2ResourcesCountriesByCountryCodeGet(countryCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling apiNskV2ResourcesCountriesByCountryCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Countryv2>(`${this.basePath}/api/nsk/v2/resources/countries/${encodeURIComponent(String(countryCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of country resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesCountriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Countryv2>,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesCountriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Countryv2>,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesCountriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Countryv2>>>;
    public apiNskV2ResourcesCountriesGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV2ResourcesCountriesGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Countryv2>>(`${this.basePath}/api/nsk/v2/resources/countries`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the specific currency resource.
     * 
     * @param currencyCode The unique currency code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesCurrenciesControllerv2ByCurrencyCodeGet(currencyCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Currency,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesCurrenciesControllerv2ByCurrencyCodeGet(currencyCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Currency,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesCurrenciesControllerv2ByCurrencyCodeGet(currencyCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Currency>>;
    public apiNskV2ResourcesCurrenciesControllerv2ByCurrencyCodeGet(currencyCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling apiNskV2ResourcesCurrenciesControllerv2ByCurrencyCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Currency>(`${this.basePath}/api/nsk/v2/resources/CurrenciesControllerv2/${encodeURIComponent(String(currencyCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of currency resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesCurrenciesControllerv2Get(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:ResourceEntriesCurrencyv2,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesCurrenciesControllerv2Get(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:ResourceEntriesCurrencyv2,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesCurrenciesControllerv2Get(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResourceEntriesCurrencyv2>>;
    public apiNskV2ResourcesCurrenciesControllerv2Get(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV2ResourcesCurrenciesControllerv2Get.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ResourceEntriesCurrencyv2>(`${this.basePath}/api/nsk/v2/resources/CurrenciesControllerv2`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the resource.
     * 
     * @param locationCode 
     * @param travelLocationCode 
     * @param cultureCode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet(locationCode: string, travelLocationCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Market,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet(locationCode: string, travelLocationCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Market,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet(locationCode: string, travelLocationCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Market>>;
    public apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet(locationCode: string, travelLocationCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (locationCode === null || locationCode === undefined) {
            throw new Error('Required parameter locationCode was null or undefined when calling apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet.');
        }

        if (travelLocationCode === null || travelLocationCode === undefined) {
            throw new Error('Required parameter travelLocationCode was null or undefined when calling apiNskV2ResourcesMarketsByLocationCodeByTravelLocationCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Market>(`${this.basePath}/api/nsk/v2/resources/markets/${encodeURIComponent(String(locationCode))}/${encodeURIComponent(String(travelLocationCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific market resource.
     * 
     * @param locationCode The unique location code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesMarketsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Market>,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesMarketsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Market>,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesMarketsByLocationCodeGet(locationCode: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Market>>>;
    public apiNskV2ResourcesMarketsByLocationCodeGet(locationCode: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (locationCode === null || locationCode === undefined) {
            throw new Error('Required parameter locationCode was null or undefined when calling apiNskV2ResourcesMarketsByLocationCodeGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('cultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Market>>(`${this.basePath}/api/nsk/v2/resources/markets/${encodeURIComponent(String(locationCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of market resources.
     * 
     * @param activeOnly Flag indicating to return just active only or all.
     * @param cultureCode The desired culture code to be returned.
     * @param eTag The cache token for this request. Data will not be returned if etag still matches.
     * @param startIndex The start index value for this request.
     * @param itemCount The item count value for this request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2ResourcesMarketsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Marketv2>,metadata:{documentation_url:string}}>;
    public apiNskV2ResourcesMarketsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Marketv2>,metadata:{documentation_url:string}}>>;
    public apiNskV2ResourcesMarketsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Marketv2>>>;
    public apiNskV2ResourcesMarketsGet(activeOnly: boolean, cultureCode?: string, eTag?: string, startIndex?: number, itemCount?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV2ResourcesMarketsGet.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }
        if (eTag !== undefined && eTag !== null) {
            queryParameters = queryParameters.set('ETag', <any>eTag);
        }
        if (startIndex !== undefined && startIndex !== null) {
            queryParameters = queryParameters.set('StartIndex', <any>startIndex);
        }
        if (itemCount !== undefined && itemCount !== null) {
            queryParameters = queryParameters.set('ItemCount', <any>itemCount);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Marketv2>>(`${this.basePath}/api/nsk/v2/resources/markets`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
