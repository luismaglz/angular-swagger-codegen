/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import {
 BookingSearchResult,
 BookingTripResult,
 DeltaMapperSingleSignOnTokenRequest,
 DeltaMapperUserRequest,
 DeltaMapperUserRolePatchRequest,
 IJsonResponse,
 SessionRoles,
 SingleSignOnTokenRequest,
 User,
 UserChangePasswordRequestBase,
 UserCustomerCreateRequest,
 UserCustomerCreateRequestv2,
 UserImpersonateRequest,
 UserRequest,
 UserRole,
 UserRoleCreateRequest,
 UserRoleEditRequest,
 UserSingleSignOnToken,
} from '../types/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class UserService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Searches the logged in user booking upcoming and past bookings.
     * This is similar to the user booking endpoint but returns more focused trip information.  This endpoint will only return data where a booking&#39;s passenger customer number matches the current logged in user.  Bookings made by the user where the passenger customer number is not assigned are ignored.
     * @param startDate Booking start search date.
     * @param endDate Booking end search date.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserBookingsByPassengerGet(startDate?: Date, endDate?: Date, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingTripResult>,metadata:{documentation_url:string}}>;
    public apiNskV1UserBookingsByPassengerGet(startDate?: Date, endDate?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingTripResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1UserBookingsByPassengerGet(startDate?: Date, endDate?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingTripResult>>>;
    public apiNskV1UserBookingsByPassengerGet(startDate?: Date, endDate?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('StartDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('EndDate', <any>endDate.toISOString());
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingTripResult>>(`${this.basePath}/api/nsk/v1/user/bookingsByPassenger`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Searches the logged in user booking upcoming and past bookings.
     * 
     * @param returnCount The number of results to be returned.
     * @param associatedFirstName An associated passenger/contact first name.
     * @param associatedLastName An associated passenger/contact last name.
     * @param phoneticSearch Flag indicating to search using the phonetic option.
     * @param tripIdentifier Filter by trip identifier.
     * @param origin Filter by origin station code.
     * @param destination Filter by destination station code.
     * @param searchArchive Flag indicating to search archived bookings.
     * @param tripDate Filter by trip date.
     * @param startDate Filter by starting search date.
     * @param endDate Filter by ending search date.
     * @param searchByCustomerNumber Flag indicating to search by the users customer number instead of user identifier.
     * @param lastBookingKey The last booking key (used for paging).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserBookingsGet(returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>;
    public apiNskV1UserBookingsGet(returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<BookingSearchResult>,metadata:{documentation_url:string}}>>;
    public apiNskV1UserBookingsGet(returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingSearchResult>>>;
    public apiNskV1UserBookingsGet(returnCount: number, associatedFirstName?: string, associatedLastName?: string, phoneticSearch?: boolean, tripIdentifier?: string, origin?: string, destination?: string, searchArchive?: boolean, tripDate?: Date, startDate?: Date, endDate?: Date, searchByCustomerNumber?: boolean, lastBookingKey?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (returnCount === null || returnCount === undefined) {
            throw new Error('Required parameter returnCount was null or undefined when calling apiNskV1UserBookingsGet.');
        }













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (associatedFirstName !== undefined && associatedFirstName !== null) {
            queryParameters = queryParameters.set('AssociatedFirstName', <any>associatedFirstName);
        }
        if (associatedLastName !== undefined && associatedLastName !== null) {
            queryParameters = queryParameters.set('AssociatedLastName', <any>associatedLastName);
        }
        if (phoneticSearch !== undefined && phoneticSearch !== null) {
            queryParameters = queryParameters.set('PhoneticSearch', <any>phoneticSearch);
        }
        if (tripIdentifier !== undefined && tripIdentifier !== null) {
            queryParameters = queryParameters.set('TripIdentifier', <any>tripIdentifier);
        }
        if (origin !== undefined && origin !== null) {
            queryParameters = queryParameters.set('Origin', <any>origin);
        }
        if (destination !== undefined && destination !== null) {
            queryParameters = queryParameters.set('Destination', <any>destination);
        }
        if (searchArchive !== undefined && searchArchive !== null) {
            queryParameters = queryParameters.set('SearchArchive', <any>searchArchive);
        }
        if (tripDate !== undefined && tripDate !== null) {
            queryParameters = queryParameters.set('TripDate', <any>tripDate.toISOString());
        }
        if (startDate !== undefined && startDate !== null) {
            queryParameters = queryParameters.set('StartDate', <any>startDate.toISOString());
        }
        if (endDate !== undefined && endDate !== null) {
            queryParameters = queryParameters.set('EndDate', <any>endDate.toISOString());
        }
        if (searchByCustomerNumber !== undefined && searchByCustomerNumber !== null) {
            queryParameters = queryParameters.set('SearchByCustomerNumber', <any>searchByCustomerNumber);
        }
        if (returnCount !== undefined && returnCount !== null) {
            queryParameters = queryParameters.set('ReturnCount', <any>returnCount);
        }
        if (lastBookingKey !== undefined && lastBookingKey !== null) {
            queryParameters = queryParameters.set('LastBookingKey', <any>lastBookingKey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingSearchResult>>(`${this.basePath}/api/nsk/v1/user/bookings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the current logged in user.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserGet(observe?: 'body', reportProgress?: boolean): Observable<{data:User,metadata:{documentation_url:string}}>;
    public apiNskV1UserGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:User,metadata:{documentation_url:string}}>>;
    public apiNskV1UserGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public apiNskV1UserGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<User>(`${this.basePath}/api/nsk/v1/user`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resets the logged in users role.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserImpersonateDelete(observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserImpersonateDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserImpersonateDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserImpersonateDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/impersonate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the logged in users current session roles state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserImpersonateGet(observe?: 'body', reportProgress?: boolean): Observable<{data:SessionRoles,metadata:{documentation_url:string}}>;
    public apiNskV1UserImpersonateGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:SessionRoles,metadata:{documentation_url:string}}>>;
    public apiNskV1UserImpersonateGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SessionRoles>>;
    public apiNskV1UserImpersonateGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SessionRoles>(`${this.basePath}/api/nsk/v1/user/impersonate`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Impersonates a new role for the logged in user.
     * 
     * @param request The user impersonate request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserImpersonatePost(request?: UserImpersonateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserImpersonatePost(request?: UserImpersonateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserImpersonatePost(request?: UserImpersonateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserImpersonatePost(request?: UserImpersonateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/impersonate`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Changes the logged in user&#39;s password.
     * 
     * @param request The change password request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPasswordChangePost(request?: UserChangePasswordRequestBase, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserPasswordChangePost(request?: UserChangePasswordRequestBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserPasswordChangePost(request?: UserChangePasswordRequestBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPasswordChangePost(request?: UserChangePasswordRequestBase, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/password/change`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the current logged in user.
     * 
     * @param request The user patch request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPatch(request?: DeltaMapperUserRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserPatch(request?: DeltaMapperUserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserPatch(request?: DeltaMapperUserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPatch(request?: DeltaMapperUserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a user with customer creation parameter defaults.
     * This endpoint will create a user based off the system configured customer creation parameters. The associated  person has to be of type customer or an exception will be thrown. To change these default settings please configure  utilities.
     * @param request The user customer create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPost(request?: UserCustomerCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserPost(request?: UserCustomerCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserPost(request?: UserCustomerCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPost(request?: UserCustomerCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the current logged in user.
     * 
     * @param request The user edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserPut(request?: UserRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserPut(request?: UserRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserPut(request?: UserRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserPut(request?: UserRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delets a specific role on the logged in user.
     * 
     * @param userRoleKey The unique user role key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesByUserRoleKeyDelete(userRoleKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesByUserRoleKeyDelete(userRoleKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesByUserRoleKeyDelete(userRoleKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserRolesByUserRoleKeyDelete(userRoleKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UserRolesByUserRoleKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/roles/${encodeURIComponent(String(userRoleKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific role from the logged in user.
     * 
     * @param userRoleKey The unique user role key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesByUserRoleKeyGet(userRoleKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:UserRole,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesByUserRoleKeyGet(userRoleKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:UserRole,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesByUserRoleKeyGet(userRoleKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserRole>>;
    public apiNskV1UserRolesByUserRoleKeyGet(userRoleKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UserRolesByUserRoleKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<UserRole>(`${this.basePath}/api/nsk/v1/user/roles/${encodeURIComponent(String(userRoleKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific role on the logged in user.
     * 
     * @param userRoleKey The unique user role key.
     * @param request The patched role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesByUserRoleKeyPatch(userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesByUserRoleKeyPatch(userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesByUserRoleKeyPatch(userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserRolesByUserRoleKeyPatch(userRoleKey: string, request?: DeltaMapperUserRolePatchRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UserRolesByUserRoleKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/roles/${encodeURIComponent(String(userRoleKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific role on the logged in user.
     * 
     * @param userRoleKey The unique user role key.
     * @param request The modified role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesByUserRoleKeyPut(userRoleKey: string, request?: UserRoleEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesByUserRoleKeyPut(userRoleKey: string, request?: UserRoleEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesByUserRoleKeyPut(userRoleKey: string, request?: UserRoleEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserRolesByUserRoleKeyPut(userRoleKey: string, request?: UserRoleEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userRoleKey === null || userRoleKey === undefined) {
            throw new Error('Required parameter userRoleKey was null or undefined when calling apiNskV1UserRolesByUserRoleKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/roles/${encodeURIComponent(String(userRoleKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all roles from the logged in user.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesGet(observe?: 'body', reportProgress?: boolean): Observable<{data:Array<UserRole>,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<UserRole>,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UserRole>>>;
    public apiNskV1UserRolesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<UserRole>>(`${this.basePath}/api/nsk/v1/user/roles`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new role on the logged in user.
     * 
     * @param request The new role.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserRolesPost(request?: UserRoleCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserRolesPost(request?: UserRoleCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserRolesPost(request?: UserRoleCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserRolesPost(request?: UserRoleCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/roles`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a token associated with the single sign on provider from the logged-in user.
     * 
     * @param providerKey The single sign on provider key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenByProviderKeyDelete(providerKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyDelete(providerKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyDelete(providerKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyDelete(providerKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerKey === null || providerKey === undefined) {
            throw new Error('Required parameter providerKey was null or undefined when calling apiNskV1UserSingleSignOnTokenByProviderKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken/${encodeURIComponent(String(providerKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a single sign on token associated with a specific user.
     * 
     * @param providerKey The single sign on provider key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenByProviderKeyGet(providerKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:UserSingleSignOnToken,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyGet(providerKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:UserSingleSignOnToken,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyGet(providerKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserSingleSignOnToken>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyGet(providerKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerKey === null || providerKey === undefined) {
            throw new Error('Required parameter providerKey was null or undefined when calling apiNskV1UserSingleSignOnTokenByProviderKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<UserSingleSignOnToken>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken/${encodeURIComponent(String(providerKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches an existing token associated with the logged-in user.
     * 
     * @param providerKey The single sign on provider key.
     * @param tokenRequest The single sign on token request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenByProviderKeyPatch(providerKey: string, tokenRequest?: DeltaMapperSingleSignOnTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPatch(providerKey: string, tokenRequest?: DeltaMapperSingleSignOnTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPatch(providerKey: string, tokenRequest?: DeltaMapperSingleSignOnTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPatch(providerKey: string, tokenRequest?: DeltaMapperSingleSignOnTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerKey === null || providerKey === undefined) {
            throw new Error('Required parameter providerKey was null or undefined when calling apiNskV1UserSingleSignOnTokenByProviderKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken/${encodeURIComponent(String(providerKey))}`,
            tokenRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Links the requested token with the logged-in user.
     * 
     * @param providerKey The single sign on provider key.
     * @param tokenRequest The single sign on token request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenByProviderKeyPost(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPost(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPost(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPost(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerKey === null || providerKey === undefined) {
            throw new Error('Required parameter providerKey was null or undefined when calling apiNskV1UserSingleSignOnTokenByProviderKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken/${encodeURIComponent(String(providerKey))}`,
            tokenRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing token associated with the logged-in user.
     * 
     * @param providerKey The single sign on provider key.
     * @param tokenRequest The single sign on token request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenByProviderKeyPut(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPut(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPut(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1UserSingleSignOnTokenByProviderKeyPut(providerKey: string, tokenRequest?: SingleSignOnTokenRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (providerKey === null || providerKey === undefined) {
            throw new Error('Required parameter providerKey was null or undefined when calling apiNskV1UserSingleSignOnTokenByProviderKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken/${encodeURIComponent(String(providerKey))}`,
            tokenRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all of the single sign on tokens associated with a specific user.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1UserSingleSignOnTokenGet(observe?: 'body', reportProgress?: boolean): Observable<{data:Array<UserSingleSignOnToken>,metadata:{documentation_url:string}}>;
    public apiNskV1UserSingleSignOnTokenGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<UserSingleSignOnToken>,metadata:{documentation_url:string}}>>;
    public apiNskV1UserSingleSignOnTokenGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<UserSingleSignOnToken>>>;
    public apiNskV1UserSingleSignOnTokenGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<UserSingleSignOnToken>>(`${this.basePath}/api/nsk/v1/user/singleSignOnToken`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a user with customer creation parameter defaults.
     * This endpoint will create a user based off the system configured customer creation parameters. The associated  person has to be of type customer or an exception will be thrown. To change these default settings please configure  utilities.
     * @param request The user customer create request v2.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2UserPost(request?: UserCustomerCreateRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2UserPost(request?: UserCustomerCreateRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2UserPost(request?: UserCustomerCreateRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2UserPost(request?: UserCustomerCreateRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v2/user`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
