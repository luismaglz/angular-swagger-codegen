/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Account } from '../model/account';
import { ActivityProduct } from '../model/activityProduct';
import { AddOn } from '../model/addOn';
import { AddOnAllowedPayments } from '../model/addOnAllowedPayments';
import { AddOnSettings } from '../model/addOnSettings';
import { AutoAssignRequest } from '../model/autoAssignRequest';
import { Booking } from '../model/booking';
import { BookingComment } from '../model/bookingComment';
import { BookingMessageHistory } from '../model/bookingMessageHistory';
import { BookingNotificationHistory } from '../model/bookingNotificationHistory';
import { BookingPointOfSaleEditRequest } from '../model/bookingPointOfSaleEditRequest';
import { BookingQueueRequest } from '../model/bookingQueueRequest';
import { BundleAvailability } from '../model/bundleAvailability';
import { BundleAvailabilityRequest } from '../model/bundleAvailabilityRequest';
import { CarProduct } from '../model/carProduct';
import { CommitPassengerFeeRequest } from '../model/commitPassengerFeeRequest';
import { CommitRequestv2 } from '../model/commitRequestv2';
import { Consumer } from '../model/consumer';
import { DeltaMapperBookingPointOfSaleEditRequest } from '../model/deltaMapperBookingPointOfSaleEditRequest';
import { DeltaMapperConsumer } from '../model/deltaMapperConsumer';
import { DeltaMapperOrderParticipantUpdateRequest } from '../model/deltaMapperOrderParticipantUpdateRequest';
import { DeltaMapperRecordLocatorEditRequest } from '../model/deltaMapperRecordLocatorEditRequest';
import { DivideRequestv2 } from '../model/divideRequestv2';
import { FareOverrideRequest } from '../model/fareOverrideRequest';
import { FareRule } from '../model/fareRule';
import { FeeRequestBase } from '../model/feeRequestBase';
import { FlightMoveHistoryResponse } from '../model/flightMoveHistoryResponse';
import { HistoryResponse } from '../model/historyResponse';
import { HotelProduct } from '../model/hotelProduct';
import { IActionResult } from '../model/iActionResult';
import { IJsonResponse } from '../model/iJsonResponse';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InsuranceProduct } from '../model/insuranceProduct';
import { OrderParticipantUpdateRequest } from '../model/orderParticipantUpdateRequest';
import { OrderPaymentBase } from '../model/orderPaymentBase';
import { PreCancelDetail } from '../model/preCancelDetail';
import { PromotionRequest } from '../model/promotionRequest';
import { RecordLocator } from '../model/recordLocator';
import { RecordLocatorCreateRequest } from '../model/recordLocatorCreateRequest';
import { RecordLocatorEditRequest } from '../model/recordLocatorEditRequest';
import { SeatAssignmentHistoryResponse } from '../model/seatAssignmentHistoryResponse';
import { SeatMapAvailability } from '../model/seatMapAvailability';
import { SegmentChangeHistoryResponse } from '../model/segmentChangeHistoryResponse';
import { SellInsuranceRequest } from '../model/sellInsuranceRequest';
import { ServiceCharge } from '../model/serviceCharge';
import { Transaction } from '../model/transaction';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BookingService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieves the account collection transactions for the booking in state.
     * 
     * @param accountCollectionKey The account collection key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Transaction>>;
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet(accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/booking/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the account and collections for the booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAccountGet(observe?: 'body', reportProgress?: boolean): Observable<Account>;
    public apiNskV1BookingAccountGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
    public apiNskV1BookingAccountGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
    public apiNskV1BookingAccountGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Account>(`${this.basePath}/api/nsk/v1/booking/account`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all of the transactions for all of the collections for the booking in state.
     * 
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Transaction>>;
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Transaction>>>;
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1BookingAccountTransactionsGet(startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1BookingAccountTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1BookingAccountTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/booking/account/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ActivityProduct>>;
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ActivityProduct>>>;
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ActivityProduct>>>;
    public apiNskV1BookingAddOnsActivitiesGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ActivityProduct>>(`${this.basePath}/api/nsk/v1/booking/addOns/activities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CarProduct>>;
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CarProduct>>>;
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CarProduct>>>;
    public apiNskV1BookingAddOnsCarsGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CarProduct>>(`${this.basePath}/api/nsk/v1/booking/addOns/cars`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<HotelProduct>>;
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<HotelProduct>>>;
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<HotelProduct>>>;
    public apiNskV1BookingAddOnsHotelsGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<HotelProduct>>(`${this.basePath}/api/nsk/v1/booking/addOns/hotels`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets default availability using details from the booking in state.  Requires a valid booking in state.
     * 
     * @param vendorCode The specific vendor code.
     * @param cultureCode The specific culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InsuranceProduct>>;
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InsuranceProduct>>>;
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InsuranceProduct>>>;
    public apiNskV1BookingAddOnsInsuranceGet(vendorCode?: string, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (vendorCode !== undefined && vendorCode !== null) {
            queryParameters = queryParameters.set('VendorCode', <any>vendorCode);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InsuranceProduct>>(`${this.basePath}/api/nsk/v1/booking/addOns/insurance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sells new insurance items.
     * 
     * @param request Quote request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe?: 'body', reportProgress?: boolean): Observable<IActionResult>;
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IActionResult>>;
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IActionResult>>;
    public apiNskV1BookingAddOnsInsurancePost(request?: SellInsuranceRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IActionResult>(`${this.basePath}/api/nsk/v1/booking/addOns/insurance`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an order customer for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The customer to update.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPatch(addOnKey: string, request?: DeltaMapperConsumer, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyCustomerPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/customer`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an order customer for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The customer to update.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyCustomerPut(addOnKey: string, request?: Consumer, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyCustomerPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/customer`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific add-on on the booking in state.
     * 
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyDelete(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific add-on from the booking in state.
     * 
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<AddOn>;
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AddOn>>;
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AddOn>>;
    public apiNskV1BookingAddonsByAddOnKeyGet(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AddOn>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a single participant for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param participantKey The unique participant key.
     * @param request The participant to update.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch(addOnKey: string, participantKey: string, request?: DeltaMapperOrderParticipantUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch.');
        }

        if (participantKey === null || participantKey === undefined) {
            throw new Error('Required parameter participantKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/participants/${encodeURIComponent(String(participantKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a single participant for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param participantKey The unique participant key.
     * @param request The participant to update.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut(addOnKey: string, participantKey: string, request?: OrderParticipantUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut.');
        }

        if (participantKey === null || participantKey === undefined) {
            throw new Error('Required parameter participantKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyParticipantsByParticipantKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/participants/${encodeURIComponent(String(participantKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific add-on&#39;s allowed payment methods.
     * If the add on&#39;s payment required flag is set to true, this endpoint  will return the allowed payment options for the add on.  If set to  false, null will be returned.
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<AddOnAllowedPayments>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AddOnAllowedPayments>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AddOnAllowedPayments>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsGet(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPaymentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AddOnAllowedPayments>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/payments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a payment to a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param request The order payment to be added.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeyPaymentsPost(addOnKey: string, request?: OrderPaymentBase, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPaymentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/payments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Pre cancels a specific add-on on the booking in state.
     * 
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<PreCancelDetail>;
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PreCancelDetail>>;
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PreCancelDetail>>;
    public apiNskV1BookingAddonsByAddOnKeyPreCancelGet(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyPreCancelGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PreCancelDetail>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/pre/cancel`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Syncs the specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingAddonsByAddOnKeySyncPut(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeySyncPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/sync`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the field validation for a specific add-on on the booking.
     * 
     * @param addOnKey The unique add on key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe?: 'body', reportProgress?: boolean): Observable<AddOnSettings>;
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AddOnSettings>>;
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AddOnSettings>>;
    public apiNskV1BookingAddonsByAddOnKeyValidationGet(addOnKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (addOnKey === null || addOnKey === undefined) {
            throw new Error('Required parameter addOnKey was null or undefined when calling apiNskV1BookingAddonsByAddOnKeyValidationGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AddOnSettings>(`${this.basePath}/api/nsk/v1/booking/addons/${encodeURIComponent(String(addOnKey))}/validation`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all the add-ons on the booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsGet(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public apiNskV1BookingAddonsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public apiNskV1BookingAddonsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public apiNskV1BookingAddonsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse200>(`${this.basePath}/api/nsk/v1/booking/addons`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all the available add-ons allowed payment methods for all the add-ons on the booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingAddonsPaymentsGet(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public apiNskV1BookingAddonsPaymentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public apiNskV1BookingAddonsPaymentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public apiNskV1BookingAddonsPaymentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2001>(`${this.basePath}/api/nsk/v1/booking/addons/payments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the baggage allowances for the current booking in state.  Baggage usage details will only be returned if includeUsageDetails  is flagged true AND the allowance behavior is NOT Default.
     * 
     * @param includeUsageDetails If true, the baggage allowance usage details will be populated in the response.  Including these details adds processing overhead, so set this only when absolutely necessary.  Defaults to &#x60;false&#x60;, not include usage details.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2002>;
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2002>>;
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2002>>;
    public apiNskV1BookingBaggageAllowancesGet(includeUsageDetails?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeUsageDetails !== undefined && includeUsageDetails !== null) {
            queryParameters = queryParameters.set('includeUsageDetails', <any>includeUsageDetails);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2002>(`${this.basePath}/api/nsk/v1/booking/baggageAllowances`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the bundle and ssr availability for the booking in-state.
     * Although this endpoint behaves like a GET, POST reduces the limitations resulting from URL length issues.
     * @param request The bundle availability request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<BundleAvailability>>;
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BundleAvailability>>>;
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundleAvailability>>>;
    public apiNskV1BookingBundleAvailabilityPost(request?: BundleAvailabilityRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<BundleAvailability>>(`${this.basePath}/api/nsk/v1/booking/bundle/availability`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the list of comments on the in-state booking.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingCommentsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<BookingComment>>;
    public apiNskV1BookingCommentsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BookingComment>>>;
    public apiNskV1BookingCommentsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingComment>>>;
    public apiNskV1BookingCommentsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingComment>>(`${this.basePath}/api/nsk/v1/booking/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Replaces an existing fare price with an amount specified.
     * 
     * @param journeyKey The journey key.
     * @param request The fare override request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingFareOverrideJourneyByJourneyKeyPost(journeyKey: string, request?: FareOverrideRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingFareOverrideJourneyByJourneyKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/fareOverride/journey/${encodeURIComponent(String(journeyKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a fare rule from the current booking in state based on  the specific fare key.
     * 
     * @param fareKey The unique fare key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe?: 'body', reportProgress?: boolean): Observable<FareRule>;
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FareRule>>;
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FareRule>>;
    public apiNskV1BookingFareRulesFareByFareKeyGet(fareKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fareKey === null || fareKey === undefined) {
            throw new Error('Required parameter fareKey was null or undefined when calling apiNskV1BookingFareRulesFareByFareKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FareRule>(`${this.basePath}/api/nsk/v1/booking/fareRules/fare/${encodeURIComponent(String(fareKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of all fare rules from the current booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFareRulesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FareRule>>>;
    public apiNskV1BookingFareRulesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FareRule>>(`${this.basePath}/api/nsk/v1/booking/fareRules`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of all fare rules from the current booking in state  for the specific journey key.
     * 
     * @param journeyKey The unique journey key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FareRule>>>;
    public apiNskV1BookingFareRulesJourneyByJourneyKeyGet(journeyKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingFareRulesJourneyByJourneyKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FareRule>>(`${this.basePath}/api/nsk/v1/booking/fareRules/journey/${encodeURIComponent(String(journeyKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the collection of all fare rules from the current booking in state for the specific segment key.
     * 
     * @param segmentKey The unique segment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FareRule>>;
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FareRule>>>;
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FareRule>>>;
    public apiNskV1BookingFareRulesSegmentBySegmentKeyGet(segmentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingFareRulesSegmentBySegmentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FareRule>>(`${this.basePath}/api/nsk/v1/booking/fareRules/segment/${encodeURIComponent(String(segmentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a fee.
     * 
     * @param feeKey The fee key request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyDelete(feeKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feeKey === null || feeKey === undefined) {
            throw new Error('Required parameter feeKey was null or undefined when calling apiNskV1BookingFeeByFeeKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/fee/${encodeURIComponent(String(feeKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Overrides a fee amount.
     * 
     * @param feeKey The fee key.
     * @param request The fee request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingFeeByFeeKeyPut(feeKey: string, request?: FeeRequestBase, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feeKey === null || feeKey === undefined) {
            throw new Error('Required parameter feeKey was null or undefined when calling apiNskV1BookingFeeByFeeKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/fee/${encodeURIComponent(String(feeKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the fee price.
     * Only service and penalty fee types support a price that is configured by the booking in state.  Depending on the configuration, the passenger key will be needed.  For other fee types the price amount is manually provided.
     * @param feeCode The fee code.
     * @param passengerKey The passenger key.
     * @param origin The origin station code.
     * @param collectedCurrencyCode The collected currency code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ServiceCharge>>;
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ServiceCharge>>>;
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ServiceCharge>>>;
    public apiNskV1BookingFeeGet(feeCode: string, passengerKey?: string, origin?: string, collectedCurrencyCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feeCode === null || feeCode === undefined) {
            throw new Error('Required parameter feeCode was null or undefined when calling apiNskV1BookingFeeGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passengerKey !== undefined && passengerKey !== null) {
            queryParameters = queryParameters.set('PassengerKey', <any>passengerKey);
        }
        if (origin !== undefined && origin !== null) {
            queryParameters = queryParameters.set('Origin', <any>origin);
        }
        if (collectedCurrencyCode !== undefined && collectedCurrencyCode !== null) {
            queryParameters = queryParameters.set('CollectedCurrencyCode', <any>collectedCurrencyCode);
        }
        if (feeCode !== undefined && feeCode !== null) {
            queryParameters = queryParameters.set('FeeCode', <any>feeCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ServiceCharge>>(`${this.basePath}/api/nsk/v1/booking/fee`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Manually adds a new fee.
     * Penalty fees, spoilage fees, and service fees can be created manually. Other types are automatically created by  the system.  Depending on the configuration, the passenger key will be needed.
     * @param request The fee request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingFeePost(request?: CommitPassengerFeeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/fee`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the current booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingGet(observe?: 'body', reportProgress?: boolean): Observable<Booking>;
    public apiNskV1BookingGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Booking>>;
    public apiNskV1BookingGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Booking>>;
    public apiNskV1BookingGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Booking>(`${this.basePath}/api/nsk/v1/booking`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current flight move history in state.
     * 
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<FlightMoveHistoryResponse>;
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FlightMoveHistoryResponse>>;
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FlightMoveHistoryResponse>>;
    public apiNskV1BookingHistoryFlightMoveGet(lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FlightMoveHistoryResponse>(`${this.basePath}/api/nsk/v1/booking/history/flightMove`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current booking history in state.
     * 
     * @param event The event that triggered the history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<HistoryResponse>;
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HistoryResponse>>;
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HistoryResponse>>;
    public apiNskV1BookingHistoryGet(event?: 'Unknown' | 'ConvertedHistory' | 'FlightTimeChange' | 'FlightDesignatorChange' | 'AssignedSeat' | 'RemoveSeat' | 'AddedFlight' | 'DeletedFlight' | 'DeletedPassenger' | 'NameChange' | 'GroupNameChange' | 'CancelledTicketing' | 'ScheduleChange' | 'AddedPayment' | 'ServiceFee' | 'QueuedPnr' | 'UnqueuedPnr' | 'DeletedComment' | 'Divided' | 'CheckedIn' | 'CheckedOut' | 'FareOverride' | 'AddedBaggage' | 'ChangedBaggageWeight' | 'CheckedBaggage' | 'RemovedBaggage' | 'BoardedPassenger' | 'UnboardedPassenger' | 'ManualAuthorization' | 'ManualDecline' | 'UndoCancel' | 'ItinerarySent' | 'ContactChange' | 'SsrAdded' | 'FlightMoved' | 'VerifiedDocument' | 'RemovedVerifiedDocument' | 'Promotion' | 'BookingComment' | 'CancelledSchedule' | 'CancelServiceFee' | 'OverrideServiceFee' | 'AddedRecordLocator' | 'DeletedRecordLocator' | 'UpgradeClassOfService' | 'DowngradeClassOfService' | 'StandbyPriorityChange' | 'AssignedTicketNumber' | 'DeletedTicketNumber' | 'ConfirmSegmentStatusCodeChange' | 'CodeshareFlightChanged' | 'PdsCancel' | 'PdsPending' | 'PdsConfirm' | 'PdsFinalized' | 'PdsDeclined' | 'PdsException' | 'PdsCancelRefused' | 'PdsCancelUnsuccessful' | 'Apps' | 'InhibitedOverride' | 'PrintedBagTag' | 'SelfPrintedBagTag' | 'PrintedBoardingPass' | 'AddCustomerId' | 'DeleteCustomerId' | 'HoldCreated' | 'HoldRemoved' | 'HoldChanged' | 'OverrideCoupon' | 'PdsSynchronized' | 'PdsItemremoved' | 'Reprice' | 'ChannelOverride' | 'EmdCreated' | 'EmdRemoved' | 'EmdChanged' | 'ServiceBundle' | 'PublishedFareOverride' | 'FareClassRealignment', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<HistoryResponse>(`${this.basePath}/api/nsk/v1/booking/history`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current message history in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistoryMessageGet(observe?: 'body', reportProgress?: boolean): Observable<Array<BookingMessageHistory>>;
    public apiNskV1BookingHistoryMessageGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BookingMessageHistory>>>;
    public apiNskV1BookingHistoryMessageGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingMessageHistory>>>;
    public apiNskV1BookingHistoryMessageGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingMessageHistory>>(`${this.basePath}/api/nsk/v1/booking/history/message`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current notification history in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistoryNotificationGet(observe?: 'body', reportProgress?: boolean): Observable<Array<BookingNotificationHistory>>;
    public apiNskV1BookingHistoryNotificationGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BookingNotificationHistory>>>;
    public apiNskV1BookingHistoryNotificationGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BookingNotificationHistory>>>;
    public apiNskV1BookingHistoryNotificationGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BookingNotificationHistory>>(`${this.basePath}/api/nsk/v1/booking/history/notification`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current seat assignment history in state.
     * 
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SeatAssignmentHistoryResponse>;
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SeatAssignmentHistoryResponse>>;
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SeatAssignmentHistoryResponse>>;
    public apiNskV1BookingHistorySeatAssignmentGet(event: 'AssignedSeat' | 'RemoveSeat', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (event === null || event === undefined) {
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingHistorySeatAssignmentGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SeatAssignmentHistoryResponse>(`${this.basePath}/api/nsk/v1/booking/history/seatAssignment`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the current segment change history in state.
     * 
     * @param event The event that triggered the seat assignment history entry.
     * @param lastPageKey The key of the last booking history item returned.
     * @param pageSize The page size for the response.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SegmentChangeHistoryResponse>;
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SegmentChangeHistoryResponse>>;
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SegmentChangeHistoryResponse>>;
    public apiNskV1BookingHistorySegmentChangeGet(event: 'AddedFlight' | 'DeletedFlight', lastPageKey?: string, pageSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (event === null || event === undefined) {
            throw new Error('Required parameter event was null or undefined when calling apiNskV1BookingHistorySegmentChangeGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (event !== undefined && event !== null) {
            queryParameters = queryParameters.set('Event', <any>event);
        }
        if (lastPageKey !== undefined && lastPageKey !== null) {
            queryParameters = queryParameters.set('LastPageKey', <any>lastPageKey);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SegmentChangeHistoryResponse>(`${this.basePath}/api/nsk/v1/booking/history/segmentChange`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the booking point of sale.
     * The ISO country code cannot be updated for a committed booking.  This value can only be  updated on an uncommitted booking.
     * @param request Details to update the point of sale.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePatch(request?: DeltaMapperBookingPointOfSaleEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/pointOfSale`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the booking point of sale.
     * The ISO country code cannot be updated for a committed booking.  This value can only be  updated on an uncommitted booking.
     * @param request Details to update the point of sale.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingPointOfSalePut(request?: BookingPointOfSaleEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/pointOfSale`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes the promotion code on the booking in state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingPromotionDelete(observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingPromotionDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPromotionDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingPromotionDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/promotion`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets a promotion code to a booking in state.
     * 
     * @param request Promotion request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public apiNskV1BookingPromotionPost(request?: PromotionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/api/nsk/v1/booking/promotion`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a promotion code to a booking in state.
     * 
     * @param request Promotion request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingPromotionPut(request?: PromotionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/promotion`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes the booking in state from a booking queue.
     * 
     * @param request The booking request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingQueueDelete(request?: BookingQueueRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/queue`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds the booking from state to a booking queue.
     * 
     * @param request The booking request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingQueuePost(request?: BookingQueueRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/queue`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a record locator from the booking.
     * 
     * @param recordLocatorKey The record locator key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete(recordLocatorKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocatorKey === null || recordLocatorKey === undefined) {
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the record locator associated with the record locator key for  the in-state booking.
     * 
     * @param recordLocatorKey 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe?: 'body', reportProgress?: boolean): Observable<RecordLocator>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RecordLocator>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RecordLocator>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet(recordLocatorKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocatorKey === null || recordLocatorKey === undefined) {
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RecordLocator>(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the data of a third party record locator on the booking.
     * 
     * @param recordLocatorKey The record locator key to update.
     * @param request The record locator update request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch(recordLocatorKey: string, request?: DeltaMapperRecordLocatorEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocatorKey === null || recordLocatorKey === undefined) {
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Replaces the data of a third party record locator on the booking.
     * 
     * @param recordLocatorKey The record locator key to update.
     * @param request The record locator update request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut(recordLocatorKey: string, request?: RecordLocatorEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (recordLocatorKey === null || recordLocatorKey === undefined) {
            throw new Error('Required parameter recordLocatorKey was null or undefined when calling apiNskV1BookingRecordLocatorsByRecordLocatorKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/recordLocators/${encodeURIComponent(String(recordLocatorKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes all record locators from the booking.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsDelete(observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/recordLocators`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all of the record locators on the in-state booking.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsGet(observe?: 'body', reportProgress?: boolean): Observable<Array<RecordLocator>>;
    public apiNskV1BookingRecordLocatorsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RecordLocator>>>;
    public apiNskV1BookingRecordLocatorsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RecordLocator>>>;
    public apiNskV1BookingRecordLocatorsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<RecordLocator>>(`${this.basePath}/api/nsk/v1/booking/recordLocators`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a third party record locator to the booking.
     * 
     * @param request The record locator request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingRecordLocatorsPost(request?: RecordLocatorCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/recordLocators`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Clears the current booking state.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingResetDelete(observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingResetDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingResetDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingResetDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/reset`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Overrides the effective sales channel for the booking in state.
     * For the overriden channel to be implemented, the booking in state must be committed after calling this endpoint.
     * @param channelType The sales channel type to override to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingSalesChannelPut(channelType?: 'Direct' | 'Web' | 'Api', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (channelType !== undefined && channelType !== null) {
            queryParameters = queryParameters.set('channelType', <any>channelType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/salesChannel`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Auto assigns seats to all passengers that do not have them for a specific journey.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param journeyKey The specific journey key to auto assign.
     * @param request The auto assign seat request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost(primaryPassengerKey: string, journeyKey: string, request?: AutoAssignRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (primaryPassengerKey === null || primaryPassengerKey === undefined) {
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost.');
        }

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyJourneyByJourneyKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}/journey/${encodeURIComponent(String(journeyKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Auto assigns seats to all selected passengers that do not have them for every journey on the booking.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param request The auto assign seat request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost(primaryPassengerKey: string, request?: AutoAssignRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (primaryPassengerKey === null || primaryPassengerKey === undefined) {
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Auto assigns seats to all passengers that do not have them for a specific journey&#39;s segment.
     * 
     * @param primaryPassengerKey The key for the primary passenger.
     * @param segmentKey The specific segment key to auto assign.
     * @param request The auto assign seat request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost(primaryPassengerKey: string, segmentKey: string, request?: AutoAssignRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (primaryPassengerKey === null || primaryPassengerKey === undefined) {
            throw new Error('Required parameter primaryPassengerKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost.');
        }

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingSeatsAutoByPrimaryPassengerKeySegmentBySegmentKeyPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/seats/auto/${encodeURIComponent(String(primaryPassengerKey))}/segment/${encodeURIComponent(String(segmentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancels the specific segment from the booking in state.
     * Calling this method will alter the existing journeyKey. If you are cancelling the only segment in a journey,  this method will behave the same as calling DELETE on /api/nsk/v1/booking/journeys/{journeyKey}.   If there are segments remaining after the delete, the Location response header will be set with   the location of the modified journey with its new key.
     * @param segmentKey The key of the specific segment to be canceled.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1BookingSegmentsBySegmentKeyDelete(segmentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV1BookingSegmentsBySegmentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/booking/segments/${encodeURIComponent(String(segmentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a comment from the booking.
     * 
     * @param commentKey The booking comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2BookingCommentsByCommentKeyDelete(commentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (commentKey === null || commentKey === undefined) {
            throw new Error('Required parameter commentKey was null or undefined when calling apiNskV2BookingCommentsByCommentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v2/booking/comments/${encodeURIComponent(String(commentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Divides the current booking.
     * A valid user must be logged in to divide a booking.
     * @param request Contains the divide request information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2BookingDividePost(request?: DivideRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v2/booking/divide`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the recommended hold date if hold is available.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingHoldAvailableGet(observe?: 'body', reportProgress?: boolean): Observable<Date>;
    public apiNskV2BookingHoldAvailableGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Date>>;
    public apiNskV2BookingHoldAvailableGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Date>>;
    public apiNskV2BookingHoldAvailableGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Date>(`${this.basePath}/api/nsk/v2/booking/hold/available`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the list of seat maps for all the journeys for the booking in state.
     * 
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SeatMapAvailability>>;
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsGet(includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includePropertyLookup !== undefined && includePropertyLookup !== null) {
            queryParameters = queryParameters.set('IncludePropertyLookup', <any>includePropertyLookup);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SeatMapAvailability>>(`${this.basePath}/api/nsk/v2/booking/seatmaps`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the list of seat maps for a specific journey&#39;s segment.
     * 
     * @param segmentKey The segment key.
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SeatMapAvailability>>;
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SeatMapAvailability>>>;
    public apiNskV2BookingSeatmapsSegmentBySegmentKeyGet(segmentKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (segmentKey === null || segmentKey === undefined) {
            throw new Error('Required parameter segmentKey was null or undefined when calling apiNskV2BookingSeatmapsSegmentBySegmentKeyGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includePropertyLookup !== undefined && includePropertyLookup !== null) {
            queryParameters = queryParameters.set('IncludePropertyLookup', <any>includePropertyLookup);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SeatMapAvailability>>(`${this.basePath}/api/nsk/v2/booking/seatmaps/segment/${encodeURIComponent(String(segmentKey))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the status of the booking commit and returns the booking.
     * There are certain booking data that are not saved to state, such as payment   attachments. This endpoint will return the booking data so that non persisted   information is returned when and only when the status code is 200. This is the   only time the data will be available.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2BookingStatusGet(observe?: 'body', reportProgress?: boolean): Observable<Booking>;
    public apiNskV2BookingStatusGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Booking>>;
    public apiNskV2BookingStatusGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Booking>>;
    public apiNskV2BookingStatusGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Booking>(`${this.basePath}/api/nsk/v2/booking/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Commits stateful changes made and processes the booking.
     * 
     * @param request Commit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV3BookingPost(request?: CommitRequestv2, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV3BookingPost(request?: CommitRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV3BookingPost(request?: CommitRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV3BookingPost(request?: CommitRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v3/booking`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Commits stateful changes made and processes the booking.
     * 
     * @param request Commit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV3BookingPut(request?: CommitRequestv2, observe?: 'body', reportProgress?: boolean): Observable<IJsonResponse>;
    public apiNskV3BookingPut(request?: CommitRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IJsonResponse>>;
    public apiNskV3BookingPut(request?: CommitRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV3BookingPut(request?: CommitRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v3/booking`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the list of seat maps for an entire journey.
     * 
     * @param journeyKey The unique journey key.
     * @param includePropertyLookup Flag indicating to include seat property lookup on the response.
     * @param cultureCode The desired culture code.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SeatMapAvailability>>;
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SeatMapAvailability>>>;
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SeatMapAvailability>>>;
    public apiNskV3BookingSeatmapsJourneyByJourneyKeyGet(journeyKey: string, includePropertyLookup?: boolean, cultureCode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (journeyKey === null || journeyKey === undefined) {
            throw new Error('Required parameter journeyKey was null or undefined when calling apiNskV3BookingSeatmapsJourneyByJourneyKeyGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includePropertyLookup !== undefined && includePropertyLookup !== null) {
            queryParameters = queryParameters.set('IncludePropertyLookup', <any>includePropertyLookup);
        }
        if (cultureCode !== undefined && cultureCode !== null) {
            queryParameters = queryParameters.set('CultureCode', <any>cultureCode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SeatMapAvailability>>(`${this.basePath}/api/nsk/v3/booking/seatmaps/journey/${encodeURIComponent(String(journeyKey))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
