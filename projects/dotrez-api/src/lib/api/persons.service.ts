/**
 * API - Current Routes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: trunk
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import {
 Account,
 AccountCollectionRequest,
 CreateAccountRequest,
 DeltaMapperPersonAddressEditRequest,
 DeltaMapperPersonAliasRequest,
 DeltaMapperPersonCommentRequest,
 DeltaMapperPersonCustomerProgramEditRequest,
 DeltaMapperPersonEditRequest,
 DeltaMapperPersonEmailEditRequest,
 DeltaMapperPersonInformationEditRequest,
 DeltaMapperPersonPhoneNumberRequest,
 DeltaMapperPersonPreferenceEditRequest,
 DeltaMapperPersonStoredPaymentUpdateRequest,
 DeltaMapperTravelDocumentEditRequestv2,
 DeltaMapperTravelNotificationEditRequest,
 IJsonResponse,
 NotificationEvent,
 NotificationEventCreateRequest,
 NotificationTimedEvent,
 NotificationTimedEventCreateRequest,
 NotificationTimedEventEditRequest,
 Person,
 PersonAddress,
 PersonAddressCreateRequest,
 PersonAddressEditRequest,
 PersonAlias,
 PersonAliasRequest,
 PersonComment,
 PersonCommentRequest,
 PersonCreateRequest,
 PersonCustomerProgram,
 PersonCustomerProgramCreateRequest,
 PersonCustomerProgramEditRequest,
 PersonEditRequest,
 PersonEmail,
 PersonEmailCreateRequest,
 PersonEmailEditRequest,
 PersonInformation,
 PersonInformationCreateRequest,
 PersonInformationEditRequest,
 PersonPhoneNumber,
 PersonPhoneNumberRequest,
 PersonPreference,
 PersonPreferenceCreateRequest,
 PersonPreferenceEditRequest,
 PersonRecord,
 PersonStoredPayment,
 PersonStoredPaymentRequest,
 PersonTravelDocument,
 PersonTravelDocumentRequest,
 Transaction,
 TransactionRequest,
 TravelDocumentEditRequestv2,
 TravelNotification,
 TravelNotificationCreateRequest,
 TravelNotificationEditRequest,
} from '../types/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class PersonsService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieves the person account collection transactions based on the person key,  the account collection key, and data in the request.
     * 
     * @param personKey The person key.
     * @param accountCollectionKey The account collection key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet(personKey: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Transaction>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet(personKey: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Transaction>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet(personKey: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet(personKey: string, accountCollectionKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an account collection transaction based on the person key, the  account collection key, and data in the request.
     * This endpoint will add a transaction to an existing account collection.  If there are no account collections, or the account collection key does  not match an existing collection, the request will fail.  To add a new account collection, see /api/nsk/v1/persons/{personKey}/account/collection.
     * @param personKey The person key.
     * @param accountCollectionKey The account collection key.
     * @param request The create transaction request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost(personKey: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost(personKey: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost(personKey: string, accountCollectionKey: string, request?: TransactionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost(personKey: string, accountCollectionKey: string, request?: TransactionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost.');
        }

        if (accountCollectionKey === null || accountCollectionKey === undefined) {
            throw new Error('Required parameter accountCollectionKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionByAccountCollectionKeyTransactionsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account/collection/${encodeURIComponent(String(accountCollectionKey))}/transactions`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an account collection based on the person key and data in the request.
     * This endpoint will create a new account collection and a transaction if no account  transaction exists or no matching collection is found.  An account collection is unique  based on the transaction code and the expiration date.  If a matching account collection  is found, a transaction for that collection is generated and the account collection will  be updated.  See /api/nsk/v1/resources/accountTransactionCodes for a list of available account transaction  codes.
     * @param personKey The person key.
     * @param request The create account collection request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountCollectionPost(personKey: string, request?: AccountCollectionRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountCollectionPost(personKey: string, request?: AccountCollectionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionPost(personKey: string, request?: AccountCollectionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAccountCollectionPost(personKey: string, request?: AccountCollectionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountCollectionPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account/collection`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the person account and credits based on the person key.
     * 
     * @param personKey The person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Account,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Account,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
    public apiNskV1PersonsByPersonKeyAccountGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Account>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates the person account based on the person key and  data in the request.
     * 
     * @param personKey The person key.
     * @param request The create account request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountPost(personKey: string, request?: CreateAccountRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountPost(personKey: string, request?: CreateAccountRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountPost(personKey: string, request?: CreateAccountRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAccountPost(personKey: string, request?: CreateAccountRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the person account status.
     * 
     * @param personKey The person key.
     * @param status The new account status.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountStatusPut(personKey: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountStatusPut(personKey: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountStatusPut(personKey: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAccountStatusPut(personKey: string, status: 'Open' | 'Closed' | 'AgencyInactive' | 'Unknown', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountStatusPut.');
        }

        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling apiNskV1PersonsByPersonKeyAccountStatusPut.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account/status`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves all transactions for every collection.
     * 
     * @param personKey The person key.
     * @param startTime The starting date and time of the date range to search in.
     * @param sortByNewest Optional filter to sort results by newest.
     * @param endTime The end date and time of the date range to search in.
     * @param pageSize Used to specify the number of records to return.
     * @param pageIndex Represents the index of the requested paged item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAccountTransactionsGet(personKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<Transaction>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAccountTransactionsGet(personKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<Transaction>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAccountTransactionsGet(personKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Transaction>>>;
    public apiNskV1PersonsByPersonKeyAccountTransactionsGet(personKey: string, startTime: Date, sortByNewest: boolean, endTime?: Date, pageSize?: number, pageIndex?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAccountTransactionsGet.');
        }

        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling apiNskV1PersonsByPersonKeyAccountTransactionsGet.');
        }

        if (sortByNewest === null || sortByNewest === undefined) {
            throw new Error('Required parameter sortByNewest was null or undefined when calling apiNskV1PersonsByPersonKeyAccountTransactionsGet.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (startTime !== undefined && startTime !== null) {
            queryParameters = queryParameters.set('StartTime', <any>startTime.toISOString());
        }
        if (endTime !== undefined && endTime !== null) {
            queryParameters = queryParameters.set('EndTime', <any>endTime.toISOString());
        }
        if (sortByNewest !== undefined && sortByNewest !== null) {
            queryParameters = queryParameters.set('SortByNewest', <any>sortByNewest);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('PageSize', <any>pageSize);
        }
        if (pageIndex !== undefined && pageIndex !== null) {
            queryParameters = queryParameters.set('PageIndex', <any>pageIndex);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Transaction>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/account/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAddressKey The unique person address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete(personKey: string, personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete(personKey: string, personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete(personKey: string, personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete(personKey: string, personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAddressKey The unique address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet(personKey: string, personAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonAddress,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet(personKey: string, personAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonAddress,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet(personKey: string, personAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAddress>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet(personKey: string, personAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAddress>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses/${encodeURIComponent(String(personAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAddressKey The unique person address key.
     * @param request The patched address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch(personKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch(personKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch(personKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch(personKey: string, personAddressKey: string, request?: DeltaMapperPersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAddressKey The unique person address key.
     * @param request The modified address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut(personKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut(personKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut(personKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut(personKey: string, personAddressKey: string, request?: PersonAddressEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut.');
        }

        if (personAddressKey === null || personAddressKey === undefined) {
            throw new Error('Required parameter personAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesByPersonAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses/${encodeURIComponent(String(personAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of addresses for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonAddress>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonAddress>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAddress>>>;
    public apiNskV1PersonsByPersonKeyAddressesGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAddress>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAddressesPost(personKey: string, request?: PersonAddressCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAddressesPost(personKey: string, request?: PersonAddressCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAddressesPost(personKey: string, request?: PersonAddressCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAddressesPost(personKey: string, request?: PersonAddressCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAddressesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/addresses`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific alias for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete(personKey: string, personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete(personKey: string, personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete(personKey: string, personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete(personKey: string, personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific alias for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAliasKey The unique person alias key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet(personKey: string, personAliasKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonAlias,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet(personKey: string, personAliasKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonAlias,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet(personKey: string, personAliasKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonAlias>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet(personKey: string, personAliasKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonAlias>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases/${encodeURIComponent(String(personAliasKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific alias for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAliasKey The unique person alias key.
     * @param request The patched alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch(personKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch(personKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch(personKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch(personKey: string, personAliasKey: string, request?: DeltaMapperPersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific alias for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personAliasKey The unique person alias key.
     * @param request The modified alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut(personKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut(personKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut(personKey: string, personAliasKey: string, request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut(personKey: string, personAliasKey: string, request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut.');
        }

        if (personAliasKey === null || personAliasKey === undefined) {
            throw new Error('Required parameter personAliasKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesByPersonAliasKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases/${encodeURIComponent(String(personAliasKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of aliases for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonAlias>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonAlias>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonAlias>>>;
    public apiNskV1PersonsByPersonKeyAliasesGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonAlias>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new alias for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new alias.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyAliasesPost(personKey: string, request?: PersonAliasRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyAliasesPost(personKey: string, request?: PersonAliasRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyAliasesPost(personKey: string, request?: PersonAliasRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyAliasesPost(personKey: string, request?: PersonAliasRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyAliasesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/aliases`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific comment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personCommentKey The unique person comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete(personKey: string, personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete(personKey: string, personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete(personKey: string, personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete(personKey: string, personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific comment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personCommentKey The unique comment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet(personKey: string, personCommentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonComment,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet(personKey: string, personCommentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonComment,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet(personKey: string, personCommentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonComment>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet(personKey: string, personCommentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonComment>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments/${encodeURIComponent(String(personCommentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific comment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personCommentKey The unique person comment key.
     * @param request The patched comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch(personKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch(personKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch(personKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch(personKey: string, personCommentKey: string, request?: DeltaMapperPersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific comment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personCommentKey The unique person comment key.
     * @param request The modified comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut(personKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut(personKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut(personKey: string, personCommentKey: string, request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut(personKey: string, personCommentKey: string, request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut.');
        }

        if (personCommentKey === null || personCommentKey === undefined) {
            throw new Error('Required parameter personCommentKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsByPersonCommentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments/${encodeURIComponent(String(personCommentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of comments for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonComment>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonComment>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonComment>>>;
    public apiNskV1PersonsByPersonKeyCommentsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonComment>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new comment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new comment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyCommentsPost(personKey: string, request?: PersonCommentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyCommentsPost(personKey: string, request?: PersonCommentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyCommentsPost(personKey: string, request?: PersonCommentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyCommentsPost(personKey: string, request?: PersonCommentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyCommentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/comments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a person by setting the record to terminated.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyDelete(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyDelete(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyDelete(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyDelete(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific email address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personEmailAddressKey The unique person email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete(personKey: string, personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete(personKey: string, personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete(personKey: string, personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete(personKey: string, personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific email address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personEmailAddressKey The unique email address key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet(personKey: string, personEmailAddressKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonEmail,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet(personKey: string, personEmailAddressKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonEmail,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet(personKey: string, personEmailAddressKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonEmail>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet(personKey: string, personEmailAddressKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonEmail>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific email address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personEmailAddressKey The unique person email address key.
     * @param request The patched email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch(personKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch(personKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch(personKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch(personKey: string, personEmailAddressKey: string, request?: DeltaMapperPersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific email address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personEmailAddressKey The unique person email address key.
     * @param request The modified email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut(personKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut(personKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut(personKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut(personKey: string, personEmailAddressKey: string, request?: PersonEmailEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut.');
        }

        if (personEmailAddressKey === null || personEmailAddressKey === undefined) {
            throw new Error('Required parameter personEmailAddressKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsByPersonEmailAddressKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails/${encodeURIComponent(String(personEmailAddressKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of email addresses for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonEmail>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonEmail>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonEmail>>>;
    public apiNskV1PersonsByPersonKeyEmailsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonEmail>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new email address for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new email address.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyEmailsPost(personKey: string, request?: PersonEmailCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyEmailsPost(personKey: string, request?: PersonEmailCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyEmailsPost(personKey: string, request?: PersonEmailCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyEmailsPost(personKey: string, request?: PersonEmailCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyEmailsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/emails`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a specific person by key.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Person,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Person,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Person>>;
    public apiNskV1PersonsByPersonKeyGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Person>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific information on the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete(personKey: string, personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete(personKey: string, personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete(personKey: string, personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete(personKey: string, personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific information from the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param personInformationKey The unique person information key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet(personKey: string, personInformationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonInformation,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet(personKey: string, personInformationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonInformation,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet(personKey: string, personInformationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonInformation>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet(personKey: string, personInformationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonInformation>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information/${encodeURIComponent(String(personInformationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific information on the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param personInformationKey The unique person information key.
     * @param request The patched information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch(personKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch(personKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch(personKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch(personKey: string, personInformationKey: string, request?: DeltaMapperPersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific information on the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param personInformationKey The unique person information key.
     * @param request The modified information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut(personKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut(personKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut(personKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut(personKey: string, personInformationKey: string, request?: PersonInformationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut.');
        }

        if (personInformationKey === null || personInformationKey === undefined) {
            throw new Error('Required parameter personInformationKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationByPersonInformationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information/${encodeURIComponent(String(personInformationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all information from the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonInformation>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonInformation>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonInformation>>>;
    public apiNskV1PersonsByPersonKeyInformationGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonInformation>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new information on the logged in user&#39;s person.
     * 
     * @param personKey The unique person key.
     * @param request The new information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyInformationPost(personKey: string, request?: PersonInformationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyInformationPost(personKey: string, request?: PersonInformationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyInformationPost(personKey: string, request?: PersonInformationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyInformationPost(personKey: string, request?: PersonInformationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyInformationPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/information`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches the person records basic information.
     * Only need to send in the data that is being requested to be updated.
     * @param personKey The unique person key.
     * @param request The person patch request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPatch(personKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPatch(personKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPatch(personKey: string, request?: DeltaMapperPersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPatch(personKey: string, request?: DeltaMapperPersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific phone number for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete(personKey: string, personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete(personKey: string, personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete(personKey: string, personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete(personKey: string, personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific phone number for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPhoneNumberKey The unique phone number key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet(personKey: string, personPhoneNumberKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonPhoneNumber,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet(personKey: string, personPhoneNumberKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonPhoneNumber,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet(personKey: string, personPhoneNumberKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPhoneNumber>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet(personKey: string, personPhoneNumberKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPhoneNumber>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific phone number for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The patched phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch(personKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch(personKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch(personKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch(personKey: string, personPhoneNumberKey: string, request?: DeltaMapperPersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific phone number for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPhoneNumberKey The unique person phone number key.
     * @param request The modified phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut(personKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut(personKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut(personKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut(personKey: string, personPhoneNumberKey: string, request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut.');
        }

        if (personPhoneNumberKey === null || personPhoneNumberKey === undefined) {
            throw new Error('Required parameter personPhoneNumberKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersByPersonPhoneNumberKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers/${encodeURIComponent(String(personPhoneNumberKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of phone numbers for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonPhoneNumber>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonPhoneNumber>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPhoneNumber>>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPhoneNumber>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new phone number for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new phone number.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPhoneNumbersPost(personKey: string, request?: PersonPhoneNumberRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersPost(personKey: string, request?: PersonPhoneNumberRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersPost(personKey: string, request?: PersonPhoneNumberRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPhoneNumbersPost(personKey: string, request?: PersonPhoneNumberRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPhoneNumbersPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/phoneNumbers`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific preference for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete(personKey: string, personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete(personKey: string, personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete(personKey: string, personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete(personKey: string, personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific preference for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPreferenceKey The unique person preference key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet(personKey: string, personPreferenceKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonPreference,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet(personKey: string, personPreferenceKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonPreference,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet(personKey: string, personPreferenceKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonPreference>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet(personKey: string, personPreferenceKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonPreference>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific preference for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPreferenceKey The unique person preference key.
     * @param request The patched preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch(personKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch(personKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch(personKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch(personKey: string, personPreferenceKey: string, request?: DeltaMapperPersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific preference for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personPreferenceKey The unique person preference key.
     * @param request The modified preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut(personKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut(personKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut(personKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut(personKey: string, personPreferenceKey: string, request?: PersonPreferenceEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut.');
        }

        if (personPreferenceKey === null || personPreferenceKey === undefined) {
            throw new Error('Required parameter personPreferenceKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesByPersonPreferenceKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences/${encodeURIComponent(String(personPreferenceKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all preferences for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonPreference>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonPreference>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonPreference>>>;
    public apiNskV1PersonsByPersonKeyPreferencesGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonPreference>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new preference for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new preference.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPreferencesPost(personKey: string, request?: PersonPreferenceCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPreferencesPost(personKey: string, request?: PersonPreferenceCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPreferencesPost(personKey: string, request?: PersonPreferenceCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPreferencesPost(personKey: string, request?: PersonPreferenceCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPreferencesPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/preferences`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific program for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personProgramKey The unique person program key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete(personKey: string, personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete(personKey: string, personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete(personKey: string, personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete(personKey: string, personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific program for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personProgramKey The unique program key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet(personKey: string, personProgramKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonCustomerProgram,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet(personKey: string, personProgramKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonCustomerProgram,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet(personKey: string, personProgramKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonCustomerProgram>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet(personKey: string, personProgramKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonCustomerProgram>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs/${encodeURIComponent(String(personProgramKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific program for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personProgramKey The unique person program key.
     * @param request The patched program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch(personKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch(personKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch(personKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch(personKey: string, personProgramKey: string, request?: DeltaMapperPersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific program for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personProgramKey The unique person program key.
     * @param request The modified program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut(personKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut(personKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut(personKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut(personKey: string, personProgramKey: string, request?: PersonCustomerProgramEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut.');
        }

        if (personProgramKey === null || personProgramKey === undefined) {
            throw new Error('Required parameter personProgramKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsByPersonProgramKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs/${encodeURIComponent(String(personProgramKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of programs for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonCustomerProgram>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonCustomerProgram>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonCustomerProgram>>>;
    public apiNskV1PersonsByPersonKeyProgramsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonCustomerProgram>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new program for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new program.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyProgramsPost(personKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyProgramsPost(personKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyProgramsPost(personKey: string, request?: PersonCustomerProgramCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyProgramsPost(personKey: string, request?: PersonCustomerProgramCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyProgramsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/programs`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the person record basic information.
     * 
     * @param personKey The unique person key.
     * @param request The person edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyPut(personKey: string, request?: PersonEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyPut(personKey: string, request?: PersonEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyPut(personKey: string, request?: PersonEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyPut(personKey: string, request?: PersonEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific stored payment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete(personKey: string, personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete(personKey: string, personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete(personKey: string, personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete(personKey: string, personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific stored payment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personStoredPaymentKey The unique stored payment key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet(personKey: string, personStoredPaymentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonStoredPayment,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet(personKey: string, personStoredPaymentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonStoredPayment,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet(personKey: string, personStoredPaymentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonStoredPayment>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet(personKey: string, personStoredPaymentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonStoredPayment>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific stored payment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The patched stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch(personKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch(personKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch(personKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch(personKey: string, personStoredPaymentKey: string, request?: DeltaMapperPersonStoredPaymentUpdateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific stored payment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personStoredPaymentKey The unique person stored payment key.
     * @param request The modified stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut(personKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut(personKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut(personKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut(personKey: string, personStoredPaymentKey: string, request?: PersonStoredPaymentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut.');
        }

        if (personStoredPaymentKey === null || personStoredPaymentKey === undefined) {
            throw new Error('Required parameter personStoredPaymentKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsByPersonStoredPaymentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments/${encodeURIComponent(String(personStoredPaymentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of stored payments for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonStoredPayment>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonStoredPayment>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonStoredPayment>>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonStoredPayment>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new stored payment for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new stored payment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyStoredPaymentsPost(personKey: string, request?: PersonStoredPaymentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsPost(personKey: string, request?: PersonStoredPaymentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsPost(personKey: string, request?: PersonStoredPaymentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyStoredPaymentsPost(personKey: string, request?: PersonStoredPaymentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyStoredPaymentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/storedPayments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a specific travel document for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete(personKey: string, personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete(personKey: string, personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete(personKey: string, personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete(personKey: string, personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a specific travel document for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personTravelDocumentKey The unique travel document key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet(personKey: string, personTravelDocumentKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:PersonTravelDocument,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet(personKey: string, personTravelDocumentKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:PersonTravelDocument,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet(personKey: string, personTravelDocumentKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PersonTravelDocument>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet(personKey: string, personTravelDocumentKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PersonTravelDocument>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the collection of travel documents for a specific person.
     * 
     * @param personKey The unique person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelDocumentsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonTravelDocument>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonTravelDocument>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonTravelDocument>>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonTravelDocument>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelDocuments`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new travel document for a specific person.
     * 
     * @param personKey The unique person key.
     * @param request The new travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelDocumentsPost(personKey: string, request?: PersonTravelDocumentRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsPost(personKey: string, request?: PersonTravelDocumentRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsPost(personKey: string, request?: PersonTravelDocumentRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelDocumentsPost(personKey: string, request?: PersonTravelDocumentRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelDocumentsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelDocuments`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete(personKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete(personKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete(personKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete(personKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification event from a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param eventType The notification event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification event for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param eventType The event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'body', reportProgress?: boolean): Observable<{data:NotificationEvent,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:NotificationEvent,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationEvent>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet(personKey: string, travelNotificationKey: string, eventType: 'DepartureDelay' | 'ArrivalDelay' | 'ScheduleChange' | 'CheckIn', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsByEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationEvent>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events/${encodeURIComponent(String(eventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification events for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet(personKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<NotificationEvent>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet(personKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<NotificationEvent>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet(personKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationEvent>>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet(personKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationEvent>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification event for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param request The notification event create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/events`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet(personKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:TravelNotification,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet(personKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:TravelNotification,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet(personKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TravelNotification>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet(personKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TravelNotification>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param request The delta mapper travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch(personKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch(personKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch(personKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch(personKey: string, travelNotificationKey: string, request?: DeltaMapperTravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param request The travel notification edit request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut(personKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut(personKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut(personKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut(personKey: string, travelNotificationKey: string, request?: TravelNotificationEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a notification timed event from a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets a notification timed event for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The timed event type.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'body', reportProgress?: boolean): Observable<{data:NotificationTimedEvent,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:NotificationTimedEvent,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationTimedEvent>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<NotificationTimedEvent>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a notification timed event for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param timedEventType The notification timed event type.
     * @param request The updated notification timed event request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut(personKey: string, travelNotificationKey: string, timedEventType: 'Departure' | 'Arrival', request?: NotificationTimedEventEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }

        if (timedEventType === null || timedEventType === undefined) {
            throw new Error('Required parameter timedEventType was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsByTimedEventTypePut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents/${encodeURIComponent(String(timedEventType))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets notification timed events for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet(personKey: string, travelNotificationKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<NotificationTimedEvent>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet(personKey: string, travelNotificationKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<NotificationTimedEvent>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet(personKey: string, travelNotificationKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NotificationTimedEvent>>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet(personKey: string, travelNotificationKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<NotificationTimedEvent>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a notification timed event for a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param travelNotificationKey The travel notification key.
     * @param request The notification timed even create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost(personKey: string, travelNotificationKey: string, request?: NotificationTimedEventCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost.');
        }

        if (travelNotificationKey === null || travelNotificationKey === undefined) {
            throw new Error('Required parameter travelNotificationKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsByTravelNotificationKeyTimedEventsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications/${encodeURIComponent(String(travelNotificationKey))}/timedEvents`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets person travel notifications for a person.
     * 
     * @param personKey The person key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsGet(personKey: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<TravelNotification>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsGet(personKey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<TravelNotification>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsGet(personKey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TravelNotification>>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsGet(personKey: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TravelNotification>>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a person travel notification for a person.
     * 
     * @param personKey The person key.
     * @param request The travel notification create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsByPersonKeyTravelNotificationsPost(personKey: string, request?: TravelNotificationCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsPost(personKey: string, request?: TravelNotificationCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsPost(personKey: string, request?: TravelNotificationCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsByPersonKeyTravelNotificationsPost(personKey: string, request?: TravelNotificationCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV1PersonsByPersonKeyTravelNotificationsPost.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons/${encodeURIComponent(String(personKey))}/travelNotifications`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search person records.
     * 
     * @param activeOnly Include active person records only.
     * @param firstName The person&#39;s first name to search by.
     * @param lastName The person&#39;s last name to search by.
     * @param firstNameMatching The matching criteria for the person&#39;s first name.
     * @param customerNumber The person&#39;s customer number.
     * @param phoneNumber The phone number to search by.
     * @param emailAddress The email address to search by.
     * @param programNumber The program number to search by.
     * @param programCode The program code to search by.
     * @param type The person type to search by.
     * @param nationalIdNumber The national ID number to search by.
     * @param nationalIdNumberMatching The matching criteria for the national ID number.
     * @param returnCount The number of results to return.
     * @param lastPersonKey The last person key (used for paging).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsGet(activeOnly: boolean, firstName?: string, lastName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', customerNumber?: string, phoneNumber?: string, emailAddress?: string, programNumber?: string, programCode?: string, type?: 'None' | 'Customer' | 'Agent', nationalIdNumber?: string, nationalIdNumberMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', returnCount?: number, lastPersonKey?: string, observe?: 'body', reportProgress?: boolean): Observable<{data:Array<PersonRecord>,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsGet(activeOnly: boolean, firstName?: string, lastName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', customerNumber?: string, phoneNumber?: string, emailAddress?: string, programNumber?: string, programCode?: string, type?: 'None' | 'Customer' | 'Agent', nationalIdNumber?: string, nationalIdNumberMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', returnCount?: number, lastPersonKey?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:Array<PersonRecord>,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsGet(activeOnly: boolean, firstName?: string, lastName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', customerNumber?: string, phoneNumber?: string, emailAddress?: string, programNumber?: string, programCode?: string, type?: 'None' | 'Customer' | 'Agent', nationalIdNumber?: string, nationalIdNumberMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', returnCount?: number, lastPersonKey?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonRecord>>>;
    public apiNskV1PersonsGet(activeOnly: boolean, firstName?: string, lastName?: string, firstNameMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', customerNumber?: string, phoneNumber?: string, emailAddress?: string, programNumber?: string, programCode?: string, type?: 'None' | 'Customer' | 'Agent', nationalIdNumber?: string, nationalIdNumberMatching?: 'StartsWith' | 'EndsWith' | 'Contains' | 'ExactMatch', returnCount?: number, lastPersonKey?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling apiNskV1PersonsGet.');
        }














        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('FirstName', <any>firstName);
        }
        if (lastName !== undefined && lastName !== null) {
            queryParameters = queryParameters.set('LastName', <any>lastName);
        }
        if (firstNameMatching !== undefined && firstNameMatching !== null) {
            queryParameters = queryParameters.set('FirstNameMatching', <any>firstNameMatching);
        }
        if (customerNumber !== undefined && customerNumber !== null) {
            queryParameters = queryParameters.set('CustomerNumber', <any>customerNumber);
        }
        if (phoneNumber !== undefined && phoneNumber !== null) {
            queryParameters = queryParameters.set('PhoneNumber', <any>phoneNumber);
        }
        if (emailAddress !== undefined && emailAddress !== null) {
            queryParameters = queryParameters.set('EmailAddress', <any>emailAddress);
        }
        if (programNumber !== undefined && programNumber !== null) {
            queryParameters = queryParameters.set('ProgramNumber', <any>programNumber);
        }
        if (programCode !== undefined && programCode !== null) {
            queryParameters = queryParameters.set('ProgramCode', <any>programCode);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('Type', <any>type);
        }
        if (nationalIdNumber !== undefined && nationalIdNumber !== null) {
            queryParameters = queryParameters.set('NationalIdNumber', <any>nationalIdNumber);
        }
        if (nationalIdNumberMatching !== undefined && nationalIdNumberMatching !== null) {
            queryParameters = queryParameters.set('NationalIdNumberMatching', <any>nationalIdNumberMatching);
        }
        if (returnCount !== undefined && returnCount !== null) {
            queryParameters = queryParameters.set('ReturnCount', <any>returnCount);
        }
        if (lastPersonKey !== undefined && lastPersonKey !== null) {
            queryParameters = queryParameters.set('LastPersonKey', <any>lastPersonKey);
        }
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('ActiveOnly', <any>activeOnly);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PersonRecord>>(`${this.basePath}/api/nsk/v1/persons`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new person record.
     * 
     * @param request The person create request.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV1PersonsPost(request?: PersonCreateRequest, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV1PersonsPost(request?: PersonCreateRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV1PersonsPost(request?: PersonCreateRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV1PersonsPost(request?: PersonCreateRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IJsonResponse>(`${this.basePath}/api/nsk/v1/persons`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patches a specific travel document for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The patched travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch(personKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch(personKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch(personKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch(personKey: string, personTravelDocumentKey: string, request?: DeltaMapperTravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPatch.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<IJsonResponse>(`${this.basePath}/api/nsk/v2/persons/${encodeURIComponent(String(personKey))}/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a specific travel document for a specific person.
     * 
     * @param personKey The unique person key.
     * @param personTravelDocumentKey The unique person travel document key.
     * @param request The modified travel document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut(personKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'body', reportProgress?: boolean): Observable<{data:IJsonResponse,metadata:{documentation_url:string}}>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut(personKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{data:IJsonResponse,metadata:{documentation_url:string}}>>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut(personKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IJsonResponse>>;
    public apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut(personKey: string, personTravelDocumentKey: string, request?: TravelDocumentEditRequestv2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (personKey === null || personKey === undefined) {
            throw new Error('Required parameter personKey was null or undefined when calling apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut.');
        }

        if (personTravelDocumentKey === null || personTravelDocumentKey === undefined) {
            throw new Error('Required parameter personTravelDocumentKey was null or undefined when calling apiNskV2PersonsByPersonKeyTravelDocumentsByPersonTravelDocumentKeyPut.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IJsonResponse>(`${this.basePath}/api/nsk/v2/persons/${encodeURIComponent(String(personKey))}/travelDocuments/${encodeURIComponent(String(personTravelDocumentKey))}`,
            request,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
